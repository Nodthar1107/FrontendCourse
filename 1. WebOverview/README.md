# Вводная лекция. Краткий обзор этапов развития веб-технологий

В этой лекции я бы хотел провести небольшой экскурс по истории развития веб-технологий. Мы рассмотрим организацию "интернета" со времен его образования и  проследим, каким образом менялся его облик ввиду появления новых технологий. Обсудим почему вообще имело место развитие веб-технологий, с какими вызовами сталкивались инженеры, а также кратенько пробежимся по популярным инструментам, характерным для своего времени.

Также мы немного познакомимся с популярными (и не очень) на сегодняшний день инструментами, рассмотрим их сильные и слабые стороны, а также обозначим области их применения. Изучив эту информацию, вы, как фронтенд-разработчики, сможете более осознанно подходить к выбору технологии для ваших будущих проектах, ведь от этого зависит то, насколько счастливо вы будете жить, сопровождая свою разработку :)

## Предпосылки

Появление World Wide Web как распределенного хранилища информации тесно связано с именем Тима Бернса Ли, которого многие называют отцом "Интернета". Он работал в научной организации CERN, в которой назревали проблемы работы с документацией для создаваемых там разработок. Отделов было много, решаемые задачи могли пересекаться. В итоге инженерам приходилось несколько раз изобретать велосипед. Это негативно сказывалось на общем темпе развития организации, и Тим Бернс Ли понял, что с этим нужно что-то делать. В 1989 году прозвучал доклад за его авторством, в котором описывалась идея создания распределенной системы хранения и доступа к текстовой информации. Таким образом, была сформулирована концепция WorldWideWeb, которая представляло собой набор гипертекстовых документов, объединенных кросс-ссылками. Доступ к этой распределенной системе предоставляется любому участнику сети.

В результате работы Тима Бернса был был создан язык гипертекстовой разметки HTML, первый веб-сервер, отдающий статические html-документы и браузер, название которого совпадало с предложенной им концепции (WorldWideWeb). Вся работа заняла у него около двух месяцев. Сам браузер умел отображать только буквы и цифры, а также позволял переходить по ссылкам. Первой веб-страницой в сети был опубликован документ, разъясняющий концепции WorldWideWeb. Спустя какое-то время Тим Бернс Ли решил опубликовать исходный код браузера, потому как считал, что истинный потенциал его детища будет раскрыт в том случае, если каждый сможет сасостоятельно изучить его структуру. Он хотел сделать веб свободным, чтобы дать ему возможность развиваться и рости.

Соответственно мы уже можем говорить о первой оформившейся структурой веб-взаимодействия между различными участниками WWW. Среди них мы можем выделить браузер и веб-сервер. Фнукции этих участнико следующие:

 - браузер
  а) отпрака запросов в сеть по протоколу HTTP;
  б) отображение документов
 - веб-сервер
  а) обработка запросов, поиск документа по соответсвующему URL в каталоге веб-сервера, а также отдача этого документа

[Веб-архитектура первого этапа](./img/simple-structure.png)

Таким образом, на заре создания структура веба была очень простой, при этом сам веб-страницы были безмолвными и неинтерактивными. Пользователи никоим образом не могли взаимодействовать с документами, а авторам веб-страниц приходилось изменять их вручную, внося правки в разметку. Это время именуется эпохой Web 1.0


## Браузерные войны

После публикации исходного кода первого браузера многие команды разработчиков занялись созданием собственных проектов. Однако многие браузеры не превносили практически ничего нового. По сути они являлись клонами WorldWideWeb. Однако вскоре появилась компания под наванием Netscape Corporation со своим браузером Netscape Navigator (бывший Mosaic, который пришлось переименовать, чтобы избежать проблем с лицинзированием). Этот браузер умел отображать картинки вместе с текстом в одном потоке, в то время как другие браузеры открывали медиафайлы в отельном окне.

Благодаря стабильной работе и кросс-платформенности браузер захватил 80% рынка. А компания на развитии браузера построила неплохой бинес на продаже лицензий к продукту для его использования в коммерческих целях. Однако как известно, там где водятся деньги, туда приходит и Microsoft. Теперь команде энтезиастов пришлось конкурировать с компанией-гигантом, которая выпустила свой браузер Internet Explorer, который был предустановлен в новой версии Windows 95. Начиная с версии IE2 стал доступен всем категориям пользователей, а с IE3 появилась поддержка сценариев на языке JavaScript, а также таблиц каскадных стилей CSS. Netscape не был готов к такому. Приложения с поддержкой новых возможностей сильно тормозили, и это был критический фактор для пользователей с ограниченным объемом трафика.

## Появление технологии CGI и шаблонизаторов

Пока браузеры вели между собой войну за клиентов и разработчиков, технологический прогресс в мире веб-технологий не стоял на месте. В 1993 году на свет появилась технология CGI (Common Gateway Interface), которая позволяла запускать серверные скрипты с помощью веб-сервера как ответ на пользовательский запрос. В те времена популярным языком для написаня CGI-приложений был Perl, поскольку он был скриптовым языком высокого уровня, и писать подобные скрипты на нем было проще, чем на Shell. Нередко можно было встретить и приложения на языке Си. Целью таких приложений была генерация веб-страничек. Веб-сервер, обрабатывая HTTP-запрос, запускал CGI-скрипт, ответственно размещенный в определенной директории, подавал все необходимые параметры в стандартный поток ввода (STDIN) и ожидал результат в стандартном потоке вывода (STDOUT). Полученный результат веб-сервер возвращал клиенту в качестве ответа.

Главное достоинство таких скриптов, состояло в том, что пользователь теперь мог взаимодействовать с приложением, вводя какие-то данные в форме и отправляя запрос к веб-серверу, а CGI-приложение с учетом введенных данных генерировало новую страницу. Таким образом, программа могла создавать странички налету, наполняя их определенными данными, например, полученными из базы данных. При этом код веб-страниц мог быть размыт по исходному скрипту.

В те времена не было каких-то общих практик по написанию CGI-приложений, поэтому люди писали, так как им хотелось. Многие приложения генерировали веб-страницы конкатенацией строк. Это усложняло процесс редактирования, дополнения и стилизации документов, поскольку вся разметка разбросана по приложению. Кроме того, в таком режиме очень легко было допустить какую-либо ошибку, нарушующую структуру документа или вносящую уязвимости в приложение. Осознав эти проблемы, сообщество стала заниматься разработкой шаблонизаторов, которое значительно упростил процесс создания веб-страниц. Использование шаблонизаторов позволяло вынести разметку в отельные html-файлы. Каждый файл мог представлять из себя независимую единицу, наполняемую некоторыми данными. Эти единицы могли описываться менее опытными специалистами - верстальщиками. Кроме того, компоненты можно было переиспользовать на других проектах.

Шаблонизаторы могли быть представлены для разных языков. Чтобы сгенерировать с их помощью страницу, необходимо было скормить ему разметку, оформленную в определенном синтаксисе, расширяющем HTML, а также предоставить ему данные в определенной форме. Одним из популярных на сегодняшний день шаблонизаторов - Mustache. Его синтаксис выглядит следующим образом:

```html
<p>Hello</p> {{name}}
{{#if person}}
  <h2>Person is present</h2>
{{else}}
  <h2>Person doesn't exsist</h2>
{{/person}}

<ul>
{{#list}}
    <li>{{name}} | {{email}}</li>
{{/list}}
</ul>
{{> footer}}
```

Шаблонизатор позволяет подставлять значение свойств некоторого объекта, выполнять условные отрисовки, перебирать элементы массива, формируя списковые структуры, а также подставлять другие фрагменты верстки в текущий документ.
 
## Краткая история JavaScript

За долгие годы JavaScript прошел путь от забавного скриптового языка до самого популярного языка программирования в мире. Впервые он появился в мае 1995 года в компании Netscape, которые хотели добавить интерактивность на веб-страницы. Примерно в то же время Sun Microsystems представила язык Java, и Netscape лицензировала его для использования в своем браузере. Однако Java оказался слишком сложным для веб-дизайнеров.

Тогда Netscape поручила Брендану Айку создать скриптовый язык, который бы напоминал Java внешне, но при этом был объектно-ориентированным, а не основанным на классах. Так всего за 10 дней появился язык, который сегодня лежит в основе большинства веб-приложений. Название "JavaScript" было выбрано по маркетинговым соображениям — Java тогда была на пике популярности, и этим решили воспользоваться.

Первая версия JavaScript залажила архитетктуру современных веб-приложений. Браузер на основе полученного документа строил DOM-дерево, а JavaScript в свою очередь позволял взаимодействовать с этой моделью, выстраивая простые интерактивные сценарии.

В 1996 Microsof выпускает язык JScript (реализацию JavaScript) в составе Internet Explorer 3, тем самым составив конкуренцию Netscape. Однако эта конкуренция привела к большой головной боли у разработчиков, поскольку разные браузеры предоставляли проприетарные фичи, пытаясь переманить к себе как можно больше разработчиков и, как следствие, клиентов. В реальности же разработчикам приходилось поддерживать несколько версий сайта под различные платформы, чтобы пользователи независимо от используемого браузера имели доступ к одному и тому же веб-ресурсу.

В результате стали сообщество стало выпускать библиотеки, учитывающие особенности каждой из платформ и предоставляющие инкапсулирующий эти тонкости интерфейс. Тем самым были предприняты попытки упростить себе жизнь.

В 1997 году компания Netscape передает спецификацию JavaScript в международную организацию ECMA, чтобы устранить несоответсвие между браузерами из-за разных реализаций. Цель — создать единый, независимый от производителей стандарт, который сможет использовать каждый. Так появилась спецификация ECMA-262, а сам язык получил название ECMAScript (JavaScript использовать не могли из-за товарного знака). JavaScript и JScript стали его диалектами. Также был создан технический комитет TC39, в который вошли представители Netscape, Microsoft, Sun Microsystems и других компаний — именно этот комитет с тех пор определяет развитие ECMAScript.

Однако Microsoft входя в состав этой организации продвигала свои идеи по стандартизации языка, и имея больший объем ресурсов, чем у Netscape постепенно вытисняла своего конкурента.


Однако не смотря на то, что появился контролирующий орган, утверждающий новые спецификации языка, это не решило все проблемы разработки, поскольку апи отдельного взятого браузера могло сильно отличаться. Например, современным стандартом добавления обработчика на элемент является метод `element.addEventListener(type, callback)`. Старые версии IE (5-8) предоставляли другой апи - `element.attachEvent(type, callback)`. Библиотека jquery скрывала все эти тонкости, обрабатывая различные сценарии поддержки стандартных интерфейсов и специфичных для отдельных браузеров. Далее будет пример на псевдокоде, как это решал jquery:

```js
jQuery.fn.on = function( eventType, handler ) {
    // Проверяем, поддерживает ли элемент современный стандарт
    if ( this.addEventListener ) {
      this.addEventListener( eventType, handler, false );
    }
    // Если нет, проверяем старый IE способ
    else if ( this.attachEvent ) {
      this.attachEvent( 'on' + eventType, handler );
    }
    // Иначе используем древнейший способ
    else {
      this[ 'on' + eventType ] = handler;
    }
};
```

Это давало разработчику простой апи для регистрации событий.

Другая сторона jquery раскрывается в двух концепциях библиотеки: "найди и сделай" и "пиши меньше - делай больше". И правда, библиотека сильно упрощала работу с DOM-модулью документа, позволяя более лаконичными конструкциями получать доступ к элементам:

```js
// vanila-js
document.querySelectorAll('h2')[1].style.setProperty('display','none');

// с использованием jquery
jQuery('h2:eq(1)').hide();
```

Другая концпеция описывает типичный набор решаемых задач. Многие веб-сайты в начале 2000-ых годов содержали достаточно простую логику по валидации пользовательских данных и преданию странице некоторого динамического поведения. Для этих задач необходимо было найти нужный элемент, повесить на него обработчик и пересчитать стиль.

## Появление MVC-фреймворков

Как мы с вами уже обсуждали, на заре веба имели место быть CGI-приложения, генерирующие динамические веб-странички в ответ на пользовательские запросы. Разрабатывались такие приложения достаточно стихийно, потому что разработчикам приходилось самостоятельно разбираться параметрами запроса, реализовывать модули маршрутизации, настраивать взаимоействие с базой данных. Такой код был плохо структурирован, поскольку он представлял из себя спагетти. Поддерживать такой код было сложно. К тому же разработчики были вынуждены самостоятельно выстраивать архитектуру приложения, что тоже накладывает дополнительные сложности.

Все изменилось в середине 2000-ых годов, когда свет увидел первые MVC-фреймворки. К популярным и наиболее передовым инструментам относятся такие фреймворки как Ruby on Rails, Django, ASP.NET и CakePHP. Использование фреймворков предоставляла разработчикам следующие преимущества:

 - готовая архитектура приложения (Model-View-Controller);
 - четкая структура проекта, в которой строго было указано, где необходимо описывать модель приложения, представление и логику для обработки запросов;
 - упрощение процесса тестирования приложения за счет встроенных инструментов;
 - инструменты кодогенерации;
 - ORM (Object Relational Mapping) - технология, позволяющая работать с реаляционными базами данных в терминах ООП через набор моделей приложения и специальных методов вместо использования SQL;
 - упрощенный процесс конфигурации приложения (фреймворки предоставляют файлы конфигурации, например, для настройки подключения к БД, подключение инициализаторов, указание путей к учетным данным (credentials) и многое другое);
 - готовая маршрутизация;
 - готовые решения для авторизации (например, Rails из коробки поддерживает механизм сессий через ключ сессии и session storage).

Использование фреймворков позволило разграничить зоны ответственности между разработчиками и отделить слои приложения друг от друга, предложили четкую структуру в противовес хаотичной разработки, сократило время выкатки новых фич.

Также для этих фреймворков была усовершенствована технология CGI (FastCGI), который ускорил процесс формирования HTTP-ответа, держа несколько экземпляров запущенных приложений. То есть теперь FastCGI запускает пулл процессов-демонов, которые ждут подключения. Это позволило сократить расходы на запуск приложений из-за расхода процессорного времени и выделение/высвобождение оперативной памяти. Кроме того, протокол позволил масштабировать веб-сервисы, поскольку под копотом он использует TCP-соединения, что позволяет размещать приложения на различных физических серверах. Также возможно поставить несколько веб-серверов одновременно.

Соответсвтенно теперь можно говорить о веб-архитектуре второго этапа:

[Веб-архитектура второго этап](./img/server-side-application-structure.png) 

Клиент:
 - отрисовывает HTML-страничку, переданную сервером;
 - манипуляция DOM;
 - взаимодействие с сервисом посредством форм.
Сервер
 - генерация динамических страниц;
 - обработка пользовательских запросов;
 - взаимодействие с хранилищем данных.

Таким образом, мы видим, что архитектура состоит из двух крупных узлов (на самом деле их больше: сервер-бд, веб-сервер, но для простоты опустим), которые выполняют свои функции. Клиент помимо отображения данных теперь умеет отвечать на простые пользовательские действия манипулированием над DOM. Однако при каждом запросе от пользователя страница в браузере перезагружалась, заставляя пользователя смотреть в белый экран. Сервер же в свою очередь вынужден на каждый запрос повторно генерировать веб-страницу, а при большом колчестве одновременных соединений это может быть затратной операцией. Также приходится гонять лишний трафик по сети.

## Появление технологии AJAX

С появлением технологии AJAX (Asynchronous JavaScript And XML) в 1999 году разработчики получили возможность отправлять ассинхронные запросы из браузера на сервер без перезагрузки самой страницы. Эта технология в дальнейшем определила вектор развития фронтенда. Теперь имеет место быть понятие фронтенд-приложения, которое самостоятельно запрашивать данные и менять наполнение страницы.

В 2004 году компания Google запустил GMail вместе с AJAX. AJAX позволил Gmail обеспечить высокую отзывчивость и интерактивность, которые тогда были беспрецедентны для веб-сайта, положив начало новой эпохе веб-приложений — Web 2.0.

Таким образом можно наблюдать утолщение веб-клиента, который получал каркас страницы от сервера и наполнял их данными, полученными по API сервера.

## Появление реактивных фронтенд-фреймворков

В 2010 году появились первые фронтенд фреймворки, с помощью которых можно было создвать настоящие веб-приложения. Теперь на клиент прилетала пустой HTML-документ, содержащий рутовый элемент и тэг скрипт, который подключал js-файл - бандл приложения, содержащий всю логику приложения. Для получения данных приложение отправляет ассинхронные запросы на сервер по API и взависимости от ответа перерисовывает пользовательский интерфейс. Такие приложения получли название SPA (Single Page Application).

Полезность новых фреймворков заключалась в том, что они позволяли разбить веб-страницы на изолирование компоненты. А подход к проектированию приложений стал называться компонентным. Эти компоненты представляли собой самостоятельные элементы страницы, например, навигационная панель, виджет с выбором даты и времени, кнопка или инпут, карточка с товаром и другие. Мелкие, независимые компоненты образовывали UI-kit (кнопки, инпуты и прочее). Другие, более крупные, представляли собой композицию из базовых компонент, образуя виджеты, реализующие конкретную фичу приложения. Для каждого компонента определен свой вход (интерфейс, представляющий собой совокупность данных, которые может отобразить компонента) и выход (фрагмент HTML, представленный в виде шаблона, описывающий внешний вид компоненты). Такой подход предоставляет разработчикам несколько преимуществ:
 
 - возможность параллельной разработки компонент интерфейса;
 - возможность переипользования компонент на других проектах;
 - возможность тестирования поведения компонент в зависимости от входных данных.

Второе преимущество фреймворков - упрощение процесса взимодействия с DOM-деревом документа. Ранее при изменении каких-то данных разработчикам приходилось отыскивать нужный элемент через `document.querySelector`, создавать новую структуру дочерних элементов, редактировать их содержимое через свойство `innerText`, привязывать дочерние элементы к родительскому и перепривязывать обработчики. Очень неудобный процесс, который влечет за собой необходимость затрагивать несколько различных мест в приложении при реакции на какое-то событие. Фреймворки сокрывают логику по работе с DOM. Разработчику необходимо только управлять потоком данных, состав которых определяет то, какие элементы будут отрисованы на странице. Однако реализация этого потока в каждом фреймворке реализована по-разному. В AngularJS и Angular (да, это два разных фреймворка) имеется двустороняя привязка данных. Это значит, что пользователь при редактировании, например, поля ввода влияет на состояние компонент, или наоборот, изменение состояния влечет за собой перерисовку UI. В библиотеке React же привязка данных одностороняя. Прежде чем новые данные отобразятся на странице, они должны быть занесены в состояние компонента. В следующей лекции будем подробно разбирать эти тонкости.

[Веб-архитектура третьего этапа](./img/spa-application-structure.png)

На этом этапе состав клиентских и серверных функций так же имзенился:

Клиент
 - хранение статических файлов;
 - отрисовка пользовательского интерфейса;
 - отправка асинхронных запросов;
 - обновление пользовательского интерфейса

Сервер:
 - обработка клиентских запросов;
 - взаимодействие с хранилищем данных.


### AngularJS

Одним из первых фронтенд-фреймворков был AngularJS, о которым мы уже немного поговорили, вышел в 2010 году. Разработку представила компания Google. Его отличительная особенность состояла в том, что инструмент предлагал сразу готовую структуру и архитектуру приложения. Фреймворк представляет собой закрытую, но конфигурированную систему компонентов:

 - шаблоны для описания UI-компонентов;
 - роутинг для настройки маршрутизации;
 - модули для реализации различных сервисов приложения;
 - внедрение зависимостей (очень мощная концепция, позволяющая связывать различные компоненты приложения воедино; она позволяет легко конфигурировать приложения, замещая одни компоненты другими без переработки архитектуру; в том число она упрощает процесс тестирования);
 - имел в основе архитектуру MVVM (Model - View - ViewModel) (об этом будем говорить в будущих лекциях).

Это была первая технология, которая закрывала базовые задачи фронтенда из коробки. Однако порог вхождения во фреймворк был достаточно высоким из-за множества сложных концепций, которые необходимо было усвоить. В первую очередь это касается начинающих специалистов.

### React

В 2013 году компания Facebook объявила о выходе такого инструмента как React. React - это библиотека, позволяющая описывать UI и логику обработки данных внутри одного компонента. Такой подход позволяет описать логику отображения различных элементов компоненты исходя из ее состояния, делая процесс формирования UI более прозрачным. Совокупность данных компоненты образует ее состояние. При изменении состояния происходит перерисовка компонента. Для получения данных от пользователя разработчику приходится описывать набор функций, которые обрабатывают DOM-события, из которых извлекаются данные и устанавливаются как новое состояние. Таким образом мы получаем однонаправленный поток данных, циркулирующий через все приложение. Данные из состояния передаются сверху вниз в дочерние компоненты, а обработчики обновляют это состояние в ответ на пользовательские действия.

React имеет следующие преимущества:

 - простой и знакомы синтаксис описания UI - JSX (он очень напоминает HTML, благодаря чему порог в технологию значительно ниже, чем в AngularJS);
 - более простая структура описания компонент (в виде самостоятельного класса или функции; чтобы описать компоненту на AngularJS необходимо было описывать несколько файлов для состояния и отображения, использовать декораторы и изучать надстройку над HTML для рендера сложных конструкций);
 - понятная документация (в том числе и на русском языке);
 - явное управление потоком данных приложения, данные передаются сверху вниз однонаправленным потоком (такой подхд помогает понять откуда пришли данные, и как они проходят через интерфейс);
 - описание поведения компонента через код;
 - предоставляет право выбора других компонент приложения (роутинг, работа с глобальным состоянием), что делает инструмент гибким при выборе архитектуры приложения;
 - реализует более эффективный алгорит обновления интерфейса на основе Virtual-DOM.

Однако некоторые преимущества инструмента так же являются и недостатками. Излишняя свобода превращается в головную боль разработчика, который должен делать выбор в пользу конкретного инструмента. Отсутствие заложенной архитектуры, как в случае с AngularJS заставляет задумываться над организацией хранения данных и о том, как они будут попадать в компоненты. Реализация сложных проектов требуют от React-разработчика большего опыта при проектирвовании приложения, потому что иначе разработка превратится в изобретение велосипеда и постоянного рефакторинга.

Тем не менее за долгое время существования инструмента сообщество утвердило более менее универсальный дизайн приложений - Flux. О нем мы будем говорить в других лекциях.

### Vue

В 2012 году бывший инженер Google собственными усилиями выпустил новый фреймворк Vue.js. В это время доминирующим фреймворком был AngularJS, а React только набирал свою популярность. Однако эти инструменты имели свою головную боль:

1. AngularJS был полноценным MVC-фреймворком, который при реализации определеннымх проектов казался слишком сложным и многословным. Имел высокую кривую входа.

2. При попытке реализовать отдельный фрагмент приложения на AngularJS в проекте тянулся весь фреймворк.

3. К тому времени AngularJS проседал по производительности в сложных сценариях. В AngularJS использовалась технология Dirty Checking, которая представляла собой цикл опроса состояния компонент на предмет измененного состояния. Если состояние изменилось, то необходимо обновить интерфейс. Кроме того Angular тянул в рантайм компилятор, преобразующий шаблоны в DOM. 

4. React все-таки представляет собой библиотеку, реализующую слой View приложения. Для реализации приложений требовалось изучать отдельные библиотеки, а также принимать архитектурные решения. Angular же очень много всего навязывал и не позволял постепенно внедрять технологию в существующий проект.

5. React предлагает много способов, как сделать одно и то же. Например, работа со стилями. Их можно вынести в отдельный CSS-файл и импортировать его в компоненту (это делается по той причине, чтобы сборщик включал стили в сборку приложения), можно описывать CSS-in-JS стили в виде объектов, которые прокидываются через свойство style, можно использовать CSS-модули, можно использовать styled-component, которые представляют собой стилизованную обертку над базовым компонентом.

Vue.js появился как золотая середина, предлагая решение этих проблем:

 - Vue представляет собой "progressive framework" - его можно постепенно внедрять, начиная как библиотеку для виджетов и расширяя до полноценного фреймворка;
 - Vue - более полноценный фреймворк, который предлагает набор встроенных решений: маршрутизация и управление глобальным состоянием;
 - фишка Vue - Single File Component, внутри которого содержится шаблон с разметкой, стили компонента и описание данных и методов по работе с ними;
 - предоставляет возможность создавать реактивные свойства, реализующих двунаправленный поток данных из формы в модель и из модели в форму (это позволяет уменьшить количество бойлер-плейта, который приходится писать в React);
 - Vue был более прост в изучении, поскольку не требовал глубокого погружения в JavaScript (для AngularJS необходимо было понимание ООП и инверсии зависимостей, для React умение - описывать классы с пониманием механизмов наследования, понимать некоторые особенности языка, как потеря контекста и его привязка через `bind(this)`);

Однако Vue также имеет и недостатки. Некоторых из них не связаны с технической составляющей. Во-первых, React и AngularJS (Angular 2+) разрабатываются копаниями гигантами, что гарантирует долгосрочную поддержку. В то время как Vue разрабатывается одним человеком, что вызывает вопросы о выживаемости фреймворка (Эван Ю, считает, что в одиночку он сможет принимать весомые решения и немедленно приступить к их воплощению, в то время как большие команды будут затягивать с этим). Другой вопрос - сообщество. Vue менее популярен по сравнению с двумя другими фреймворками, однако на сегодняшний день его популяность растет. Сегодня фреймворк можно чаще встретить на азиатском рынке (его используют такие компании как Alibaba и Xiaomi).

### Небольшой итог по фреймворкам

На сегодняшний день многие слабые стороны фреймворков связанные с производительностью активно закрываются. Все эти инструменты образуют "святую троицу" как наиболее зарекомендовавшие себя инструменты. Если говорить об Angular (AngularJS считается устаревшим фреймворком, в то время как Angular по сути его развитие), то он занял нишу Entrprise-проектов с набором готовых архитектурных решений, повышвающий надежность приложений и "долговечность" написанного кода (код реже переписываются из-за неправильно принятых решений). Что же касается React и Vue, то сегодня разница между ними постепенно размывается. React зарекомендовал себя как хороший инструмент для разработки больших приложений. React имеет большую экосистему пакетов и зрелые DevTools(-ы). Vue же первое время больше воспринимался как игрушечная технология, больше подходящая для разработки маленьких проектов. Сегодня с выходом Vue3 популярность Vue существенно выросла Хотя суммарное сообщество Vue все еще уступает React, его рост устойчив: Vue быстро набирает звезды на GitHub и расширяет экосистему​. Поэтому выбор между Vue и React больше сводится к предпочтениям разработчиков.

## Появление языка TypeScript

В 2012 появилась спецификация языка Typescript, представленная корпорацией Microsoft. TypeScript — это строго типизированный, объектно-ориентированный язык программирования с открытым исходным кодом, который расширяет возможности JavaScript путем добавления статической типизации и других мощных функций.

Язык позволяет объявлять различные типы переменных и параметров функций, что предоставляет разработчикам синтаксические подсказки и автокомплиты, управляющие процесс разработки, а также отлавливать ошибки типизации на фазе статического анализа и компиляции. В результате компиляции код превращается в JavaScript, который выполняется на какой-то платформе. Сегодня, например, последние версии NodeJS предоставляют нативную поддержку языка без предварительной компиляции.

LSP-плагины для различных сред разработки упрощают процесс рефакторинга кода, подсвечивая различные ошибки в редакторе. Также тайпскрипт внедряет некоторые концепции, расширяющие ООП - интерфейсы, protected-методы.

Для включения TypeScript(-а) в проект необходимо описать tsconfig.json файл, описывающий конфигурацию языка, включаемые проверки синтаксиса и другие фичи. А также включить процесс компиляции в сборку приложения, вызовом компилятора tsc.

## Как итог

В рамках этой статьи мы рассмотрели как менялась структура веба под воздействием пользовательских потребностей, а также как изменялись инструменты, реализующие эти потребности. На сегодняшний день веб это большая плафторма, где мы можем встретить удивительные приложения разного назначения: облачные сервисы, стриминговые платформы и платформы, позволяющие проектировать другие информационные системы. Современные инструменты позволяют разрабывать приложения любой сложности. Они предоставляют большую экосистему готовых решений и инстурментов, позволяющих профилировать приложение, отслеживать потоки данных и исследовать инциденты. Нередко между разработчиками на различных стекахразгораются идеалогические войны, в попытках выяснить, чей стек лучше :).  Однако важно помнить, что фреймворк это всего лишь инстурмент, который мы вольны выбирать исходя из наших личных предпочтений и его пользы на проекте.

## Источники

1. Нужно ли знать историю фронтенда, если просто пишешь на React? Да, и вот почему - https://habr.com/ru/companies/netologyru/articles/907706/
2. Великие умы ИТ-мира. Тим Бернерс-Ли - https://habr.com/ru/companies/sberbank/articles/947914/
3. Забытые технологии: CGI - https://habr.com/ru/articles/872596/
4. Зачем нам JQuery? - https://habr.com/ru/companies/piter/articles/308134/
5. Краткая история JavaScript - https://habr.com/ru/companies/timeweb/articles/913894/
6. Как война браузеров изменили ландшафт Интернета - https://habr.com/ru/companies/ispsystem/articles/712370/
7. React vs Vue – подробное сравнение и перспективы - https://habr.com/ru/articles/904698/
