<style>
    .variable {
        color: blue;
        font-weight: bold;
    }

</style>

# Содержание

1. [Подключение JavaScript к веб-странице](#подключение-javascript-к-веб-странице)
2. [Immediately Invoked Function Expression](#immediately-invoked-function-expression)
3. [Шаблон открытого JS модуля](#шаблон-открытого-js-модуля)
4. [CommonJS](#commonjs)
5. [AMD (Asynchronous Module Definition) модули](#amd-asynchronous-module-definition-модули)
6. [ECMAScript-модули](#ecmascript-модули)
7. [Резюме](#резюме)

# Посвящение в модульные системы JS

Первое, с чем мне бы хотелось вас познакомить - это модульные системы. Модульные системы являются ключевым аспектом любого языка программирования, без которых очень сложно представить современную разработку. Однако JavaScript долгое время не имел нативной поддержки модулей, поскольку язык изначально был разработан для написания простых сценариев, повышающих интерактивность веб-страниц.

Современные веб-сайты полноправно считаются настоящими веб-приложениями, поскольку теперь они включают множество взаимосвязанных скриптов, реализующих сложную логику по обработке пользовательских данных, управлению состоянием приложения и динамическому отображению пользовательского интерфейса. Поддержка всей этой логики была бы невозможна без наличия модульных систем, многие из которых были предложены сообществом для решения определенных проблем разработки. А начиная со спецификации ES6 (ECMAScript 6), в язык была добавлена нативная модульная система с элегентным синтаксисом и полезными фичами, которая по сути считается стандартом современной разработки

В рамках этой лекции я проведу небольшой экскурс по существующим модульным системам, разберу достоинства и недостатки каждой из них, а также расскажу об особенностях работы с наиболее распространенными модульными системами CommonJS и ES.

## Подключение JavaScript к веб-странице

Давайте сначала посмотрим, как мы подключаем скрипты к нашей веб-странице. Мы сверстали какой-то макет, и теперь хотим оживить его. Для этого мы воспользуемся тэгом <span class="variable">script</span>, который подключим в секции <span class="variable">head</span>. Да, скорость отрисовки документа от этого упадет, но в данном примере для нас это не имеет значения. Демонстрация следующих примеров взята из проекта [GlobalScope](./GlobalScope/)

Возьмем простой макет документа:

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="./dist/index.js"></script>
    </head>
    <body>
    </body>
</html>
```

Разметка содержит минимальное количество тегов. Сфокусируемся только на подключении элемента. Браузер, заметив тэг скрипт, начинает его загруку с веб-сервера, сохраняет его в браузерный кэш, а потом начинает исполнять сам скрипт.

Пускай в index.js будет содержаться следующий код:

```js
// index.js

function foo(arg) {
    console.log(arg);
}

foo("Aboba");
```

В результате выполнения этого кода мы увидим вывод сообщения в консоль.

Теперь давайте предположим, что логика нашего скрипта разрослась, и мы решили разбить наше логику на независимые модули. Вынесем функцию <span class="variable">foo</span> в module.js.

```js
// module.js

function foo(arg) {
    console.log(arg);
}

// index.js
foo("Aboba");
```

Добавим в секцию head еще один тэг <span class="variable">script</span> следующим образом:

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="./dist/index.js"></script>
        <script src="./dist/module.js"></script>
    </head>
    <body>
    </body>
</html>
```

Перезапустим веб-страницу и увидим ожидаемую ошибку, поскольку исполняющая среда ничего не знает о функции <span class="variable">foo</span>.

Теперь давайте попробуем изменить порядок подключения скриптов:

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="./dist/module.js"></script>
        <script src="./dist/index.js"></script>
    </head>
    <body>
    </body>
</html>
```

Перезапустим страницу и увидим, что наш код работает. Как же это произошло? Нам ведь известно, что код, размещенный в отдельном файле становится изолированным, если явно не прописать интерфейс этого модуля (перечислить набор экспортируемых сущностей). Все дело в том, что долгое время платформы, на которых исполнялся JavaScript, не имели встроенной поддержки модулей (за исключением Node.js, которая имела собственную модульную систему CommonJS).

Так все-таки как же возможен вызов функции <span class="variable">foo</span> определенной в module.js из index.js без явных инструкций импорта и экспорта? Все дело в том, что любая сущность, определяемая в на верхнем уровне файла (не вложена в какую-либо другую сущность) привязывается к контексту глобального объекта <span class="variable">window</span>. Этот объект содержит всю информацию о браузерном окне, а также о создаваемых объектах верхнего уровня, как наша функция <span class="variable">foo</span>. То есть, когда исполнящая среда всречает объявление функции или переменной через ключевое слово <span class="variable">var</span>, то для <span class="variable">window</span> создается новое свойство с соответсвующим именем, куда копируется ссылка на соответсвующий объект. Напомним, что любая сущность, с которой мы имеем дело в JS, является объектом. Функция в данном контексте является функциональным объектом, для которого определен набор методов, а также оператор <span class="variable">()</span>, с помощью которого можно осуществить вызов функции.

Так вот, после загрузки module.js функция <span class="variable">foo</span> привязывается к контексту окна браузера, благодаря чему, она доступна из index.js. Таким же образом мы можем обратиться к функции <span class="variable">foo</span> через объект <span class="variable">window</span>

```js
window.foo();
```

Для ключевого слова <span class="variable">var</span> есть одна оговорка. Привязка к <span class="variable">window</span> осуществляется только в том случае, если <span class="variable">var</span> используется в глобальном скоупе. Если использовать <span class="variable">var</span> внутри функции, то областью видимости переменной будет вся функция, даже в той части кода, где перемененная еще не была объявлена. Такое явление называется hoisting.

Объявив в module.js переменную через ключевое слово <span class="variable">var</span>, мы добъемся такого же поведения, что и для функции.

С выходом стандарта ES6 в языке JS полявились такие ключевые слова как <span class="variable">let</span> и <span class="variable">const</span>, которые были призваны заменить объявление переменных через <span class="variable">var</span>, поскольку с их помощью переменные больше не попадали в контекст <span class="variable">window</span>. Ключевые слова <span class="variable">let</span> и <span class="variable">const</span> позволяли объявлять переменные с блочной областью видимости. То же происходит и с синтаксисом объявления классов. Однако использование этого нового синтаксиса все равно приводит к тому, что объекты доступны в глобальном контексте. Такое поведение приводит к засорению глоабльного контекста. А это в свою очередь может привести к сложно отлавливаемым ошибкам в логике работы приложения, особенно при командной разработке. Разработчикам придется очень тщательно следить за именованием переменных, чтобы не приводить к конфликтам имен, из-за которых возможно возникновение неожиданных побочны эффектов, из-за чего поддержка приложения и разработка нового функционала будет значительно усложнятся.

Все эти проблемы возникают при отсутсвии поддержки модулей в языке на уровне платформ. Из-за чего разработчики сами принялись разрабатывать собственные инструменты для упрощения разработки.

## Immediately Invoked Function Expression

Давайте определимся с тем, что такое модуль и какие преимущества в разработке дает модульная система. В большинстве языков программирования модуль представляет собой единицу компиляции, то есть файл, содержащий в себе последовательность инструкций, которые существуют в изолированном контексте. Изоляция это механизм, который ограничивает видимость переменных, функций и других сущностей внутри модуля, предотвращая их случайное влияние на глобальную область видимости или другие модули. Поддержка этого механизма в языке значительно упрощает процесс разработки логики приложения, его отладки и тестирования.

Как уже было сказано, ключевые слова <span class="variable">let</span> и <span class="variable">const</span> имеют блочную область видимости. Таким образом, мы можем попробовать обернуть объявление объектов в функцию следующим образом:

```js
() => {
    const A = 10;
    
    const foo = () => {
        console.log("foo");
    }
}
```

Однако код внутри этой анонимной функции не исполняется. Для этого можно воспользоваться немедленно вызываемым выражением. Выглядит это следующим образом

```js
(() => {
    const A = 10;
    
    const foo = () => {
        console.log("foo");
    }
})()
```

Отлично, теперь этот код вызывается в момент определения этой функции, а объявленные внутри нее объекты изолированы от внешней среды. Однако модули мы описываем с той целью, чтобы предоставить его функциональность внешнему миру, а его внутреннюю реализацию, наоборот, сокрыть. Второго условия мы уже добились. Осталось только описать интерфейс нашего модуля. Делается это так:

```js
const module = (() => {
    return {
        A: 10,
        foo: () => console.log("foo")
    }
})();
```

Такая запись порождает объект с полями <span class="variable">A</span> и <span class="variable">foo</span>, а <span class="variable">module</span> является ссылкой на этот самый объект. Получается, что <span class="variable">module</span> это ссылка на экземляр модуля. Теперь, зная особенности браузерного движка, мы можем обращаться к функционалу этого модуля.

```js

// module.js
const module = (() => {
    return {
        foo: () => {
            console.log(10 + 5)
        },
        sum: (a, b) => {
            return a + b;
        }
    }
})();

// index.js
module.foo()

console.log(module.sum(1, 2)) // -> 3
```

Соблюдая правильный порядок подключения скриптов (сначала идет подключение зависимостей) мы получаем рабочий код.

Теперь давайте посмотрим, как же модули могут работать с собственными зависимостями. Поскольку создание модуля осуществляется с помощью немедленно вызваемой функции, то эта функция на вход может принимать набор аргументов. Этими самыми аргументами могут являться экземпляры других модулей.

```js
// module1.js
const module1 = (() => {
    return {
        foo: () => {
            console.log(10 + 5)
        },
        sum: (a, b) => {
            return a + b;
        }
    }
})();

// module2.js
const module2 = ((dependencyModule) => {
    return {
        sumWithLogs: (a, b) => {
            console.log(`INFO: arg1: ${a} arg2: ${b}`);

            return dependencyModule.sum(a, b);
        }
    }
})(module1);
```

В качестве аргумента в модуль 2 передаем уже созданный экземпляр модуля 1. Снова обращаю внимание на порядок подключения скриптов, чтобы все остальные модули правильно разрешились. Теперь оба модуля можно использовать в index.js.

### Достоинства

К достоинствам можно отнести следующие моменты:

 - появилась возможность объявления переменных, не засоряющих глоабльный контекст;
 
По сути все достоинства этой системы вытекают из свойств изолированности:
 - ограничение области видимости переменных (возможность создания приватных переменных, используемых функцими модуля);
 - частичное решение проблемы побочных эффектов (как следствие упрощение процесса отладки);
 - упрощение процесса поддержки логики приложения (разумеется по сравнению с проектами, где модульность отсутсвует вовсе).

### Недостатки

 - глобальная область по-прежнему захламляется, но теперь это происходит на уровне объявляемых модулей;
 - необходимость вручную управлять подключением зависимостей;
 - необходимость вручную разрешать зависимости, например, циклические зависимости на этапе создания модулей;
 - невозможность ассинхронной загрузки скриптов (имеетс ввиду, что модульная система сама по себе не позволяет это сделать).
 - связи между модулями при прочтении кода не очевидны.

## Шаблон открытого JS модуля

Следуящая модульная система так же является IIFE модулем, однако здесь акцент делается на определении интерфейса модуля как локальных переменных внутри анонимной функции, которые потом включаются в экземпляр модуля как набор идентификаторов.

```js
// module.js
const module = (() => {
    const foo = () => {
        console.log(10 + 5)
    };

    const sum = (a, b) => a + b;
    
    return {
        foo,
        sum
    };
})();


// index.js
module.foo() // -> 15
console.log(module.sum(1, 2)) // -> 3
```

Такая организация кода упрощает процесс чтения разработчиком интерфейса модуля и дальнейшую работу с ним.

## CommonJS

В 2009 году появилась новая платформа для исполнения JavaScript-кода NodeJS. Платформа стала популярна благодаря множеству факторов:

 - возможность разработки бэкенда на том же языке, что используется для клиентских приложений (этот факт представляет разработчикам целый ряд преимущества)
   - универсальность кода в применяемом стеке технологий (разработчики )
   - повторное использование зависимостей в обеих средах (это преимущество стало еще более очевидным, когда появилис сборщики, такие как webpack)
   - возможность рендера приложения как на клиенте так и на сервере (например, использования технологии Next.js)
 - неблокирующий ввод/вывод (речь об ассинхронных IO-операциях, которые в существующих инструментах выполняются синхронно и блокируют поток/процесс, обрабатывающий HTTP-запрос) и как следствие высокая
 - использование встроенного JIT-компилятора, увеличивающего производительность исполнения кода и повышающего привлекательность этой технологии в совокупности с языком JS

Для работы с NodeJS есть прекрасный менеджер версий NodeJS - nvm (Node Version Manager), который позволяет с легкостью переключаться между версиями платформы. Для установки зависимостей используется пакетный менежер npm.

Статья про платформу NodeJS, сценарии ее применения, достоинства и ограничения: https://habr.com/ru/companies/ruvds/articles/345164/

Разработчики NodeJS так же привнесли в платформу новую модульную систему, которая называется CommonJS. Она поддерживается на уровне движка. Код в каждом файле находится в изолированном окружении. Однако эта изолированность достигается одним приемом. Дело в том, что когда загрузчик грузит наш код в среду NodeJS, он оборачивает его в немедленно вызываемую функцию:

```js
(function(exports, require, module, __filename, __dirname) {

// Код из файла

}());
```

Идея очень похода на те шаблоны, которые мы уже видели. Изолированность кода достигается с помощью функции.

### Параметры __filename и __dirname

Теперь поговорим про аргументы. Функция принимает несколько объектов. Начнем с самого простого - <span class="variable">__filename</span> и <span class="variable">__dirname</span>. Их смысл понятен из названия. Сценарии использования этих параметров мы рассмотрим, когда будем знакомиться с webpack.

### Параметр exports

Параметр <span class="variable">exports</span> используется для именованного экспорта объектов. Пример:

```js
// module.js
function sum(a, b) {
    return a + b;
}

const MATH_PI = 3.14;

exports.sum = sum;
exports.MATH_PI = MATH_PI
```

Другой вариант экспорта:

```js
// module.js
exports.sum = function (a, b) {
    return a + b;
}

exports.MATH_PI = 3.14
```

Важно помнить, что exports это ссылка на объект, который будет содержать набор экспортируемых значений

```js
console.log(exports) // -> {"sum": Function, "MATH_PI": 3.14 }
```

Так как exports это ссылка на объект, который мы наполняем экспортируемыми объектами, то следующая конструкция с точки зрения импортов будет не верной:

```js
exports = function () {}
```

<span class="variable">exports</span> будет содержаться ссылка на анонимную функцию, а не тот объект, который нам был передан в функцию модуля. Поэтому <span class="variable">exports</span> используем только через точку и имя свойства. Такой экспорт называется именованным.

### Параметр module

Для третьего варианта экспорта воспользуемся параметром <span class="variable">module</span>:

```js
// module.js
function sum(a, b) {
    return a + b;
}

const MATH_PI = 3.14;

module.exports = {
    sum,
    MATH_PI
}
```

Дело в том, что параметр <span class="variable">module</span> представляет собой полное описание модуля, которое так же содержит <span class="variable">__filename</span> и <span class="variable">__dirname</span>, набор экспортируемых объектов, набор путей, где необходимо искать зависимости при их загрузке, а также флаш <span class="variable">loaded</span>, который установлен, если модуль уже загружен в среду node.

Еще один вариант экспорта - экспорт по умолчанию. Он выглядит следующим образом:

```js
module.exports = function () {
    // тело функции
}
```

Пользоваться можно любыми вариантами синтаксиса, но с пониманием того, что происходит. Дело в том, что их совместное использование может привести к ошибкам. Пример:

```js
module.exports = function () {
    // тело функции
}

// У анонимной функции появится свойство sum 
module.exports.sum = function(a,b) {
    return a + b;
}
```

В этом примере мы сначала импортировали функцию в соотвесвии с правилами дефолтного экспорта. Так как в JS все является объектом, то функция тоже является объектом, для которой можно задать новые свойства, что и проиходит в случае экспорта <span class="variable">sum</span>. Функция сложения теперь является свойством анонимной функции. Это значит, что возможны следующие вызовы:

```js
// вызов анонимной функции
module.exports();

// вызов функции sum
module.exports.sum();
```

Второй пример, когда мы теряем часть экспорта:

```js
// Именованный экспорт 
module.exports.sum = function(a,b) {
    return a + b;
}

// module.exports -> { "sum": sum }

// Экспорт по умолчанию перезатирает объект, содержащий sum
module.exports = function () {
    // тело функции
}
```

В этом случае мы перезатерли объект, содержащий именованный экспорт

### Загрузка зависимостей через require

Для загрузки зависимостей в NodeJS используется функция <span class="variable">require</span>. Выглядит это слеующим образом:

```js
const path = require("path");
```

В node_modules для NodeJS поставляется пакет __path__, который позволяет работать с путями и осуществлять различные преобразования над ними. Переменная <span class="variable">path</span> представляет собой объект, поэтому работа с модулем следующая:

```js
const path = require("path")

// Подняться на директорию выше
const parentDir = path.resolve(__dirname, "..")
```

Соответсвенно, если модуль содержит импорт по умолчанию, то работа с зависимостями может выглядеть следующим образом:

```js
// module.js

module.exports = function() {
    // какая-то логика
}

// index.js
// node умеет разрешать имена модулей
const module = require("module");

// Поскольку экспорт модуля это функция, то возможен такой вызов
module();
```

Примеры взяты из проекта [CommonJS](./CommonJS/). Для запуска приложения:

```
node src/index.js
```

Для запуска сборки под браузер:

```
npm run build
```

### Применение модульной системы

Поскольку система модулей CommonJS была разработана для NodeJS, то и используется она на сервере. В браузере такой код работать не будет, поскольку там нет определения используемых в node объектов и функции require. Однако такие инструменты как Webpack и Vite (бандлеры) умеют преобразовывать CommonJS модули, чтобы они могли исполняться в браузере. В сборку добавляется overhead предоставляющий реализацию функции require. В результате код может быть запущен в браузере.

### Достоинства

 - можно считать, что CommonJS первая нативная модульная система в стеке технологий JS;
 - не требуте от разработчика дополнительных накладных;
 - возможность импорта зависимостей в любом месте проекта (например, в условных конструкция);

### Недостатки

 - необходимо привыкнуть к механизму экспорта и импорта, поскольку он содержит множество вариантов синтаксиса со своими нюансами;
 - не имеет поддержки в браузере, требует использования допольнительных инструментов для транспиляции кода;
 - синхронная загрузка зависимостей (исполнение кода прекращается, пока не будет загружен новый модуль);
 - сложен для статического анализа зависимостей бандлерами (tree shaking), поскольку require это функция, и может вызываться в соотвесвии с логикой кода (нельзя исключить зависимость из сборки; нельзя включить в сборку только используемые в рамках эскопрта объекты);
 - не является стандартом ECMAScript (предложена сообществом) (это значит, что браузеры не обязаны поддерживать эту модульную систему, что негативно сказывается на разработке в целом)

### Наследие

На сегодняшний день npm-репозиторий имеет наибольшее количество модулей, чем какой-либо другой. Это значит, что очень много кода написано с использованием модульной системы CommonJS. А это значит, что для разработки новых модульных систем придется учитывать особенности CommonJS. О некоторых из них будем говорить далее.

Про использование NodeJS крупными компаниями: https://habr.com/ru/companies/vdsina/articles/552008/

## AMD (Asynchronous Module Definition) модули

Для своего времени это была революционная технология. Исходя из названия, она позволяла осуществлять ассинхронную загрузку модулей, а также выстраивать более явные между модулями и их зависимостями. Кроме того, AMD значительно упрощает процесс подключения скриптов к веб-странице. Достаточно только подключить модуль-библиотеки, реализующий функционал AMD. Самой популярной реализацией является [RequireJS](https://requirejs.org/).

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script src="../lib/require.js"></script>
        <script src="../src/index.js"></script>
    </head>
    <body>
    </body>
</html>
```

Модульная система предоставляла несколько ключевых функций.

<span class="variable">define</span> - вызов этой функции позволяет определить модуль. Функция принимает несколько аргументов, которые позволяют задать имя модуля, перечислить массив зависимостей этого модуля, а также функцию. Эта фукнция задает изолированный контекст модуля, внутри которого может быть объявлено все что угодно. Возвращаемое значение задает интерфейс модуля, а набор параметров предствляет собой набор зависимостей.

```js
// module1.js
define("module1", () => {
    return {
        foo: () => {
            console.log(10 + 5)
        },
        sum: (a, b) => {
            return a + b;
        }
    }
});

// module2.js
define('module2', ['module1'], (module1) => {
    return {
        sumWithLogs: (a, b) => {
            console.log(`INFO: arg1: ${a} arg2: ${b}`);

            return module1.sum(a, b);
        }
    }
});
```

<span class="variable">require</span> - позволяю осуществить загрузку нескольких модулей. Эта функция принимает массив имен зависимостей, которые мы хотим загрузить, а также функцию, в которой определяется логика, использующая зависимости.

```js
require(['module1', 'module2'], (module1, module2) => {
    module1.foo()

    console.log(module1.sum(1, 2));

    module2.sumWithLogs(1, 2)
});
```

Кроме того, библиотека предоставляет возможности для конфигурации функции <span class="variable">require</span>. На самом деле <span class="variable">require</span> принимает некоторый путь к модулю (относительно чего этот путь задается я, честно говоря, не разобрался), где происходит подключение.

```js
// index.js
require.config({
    baseUrl: '../src/modules'
});

require(['module1', 'module2', 'utils/module3'], (module1, module2, module3) => {
    module1.foo()

    console.log(module1.sum(1, 2));

    module2.sumWithLogs(1, 2)

    module3.foo();
});
```

В этом примере мы настроили базовый url к директории, где лежат модули. Так же возможно создавать алиасы для модулей, чтобы так же упрощать обращение к ним.

```js
// index.js
require.config({
    baseUrl: '../src/modules',
    paths: {
        module3: 'utils/module3'
    }
});

require(['module1', 'module2', 'utils/module3'], (module1, module2, module3) => {
    // ...
});
```

Можно сказать, что по некоторым своим аспектам, например, использование функции <span class="variable">require</span> функционал библиотеки напоминает работу с [CommonJS](#commonjs) модулями. На самом деле так и есть. Авторы библиотеки при разработке AMD обращали внимание на синтаксис импорта/экспорта в [CommonJS](#commonjs). Однако в поведении функций существует разница. В случае NodeJS вызов require инициирует синхронную загрузку зависимостей. При этом код зависимых пакетов уже должен быть размещен в файловой системе. В случае RequireJS загрузка модулей осуществляется ассинхронно, поскольку весь код приходит из сети. В момент загрузки скрипта исполнение кода не блокируется до тех пор, пока браузер не загрузит зависимый модуль и не начнет исполнять его.

### Достоинства

 - AMD-модули позволили явным образом объявлять модули и отслеживать зависимости между ними (зависимые модули указываются при создании модуля функцией define);
 - разработчикам больше не нужно руками добавлять в html-документ тэги script для загрузки зависимостей (RequireJS самостоятельно управляется с загрузкой всех файлов);
 - технология самостоятельно занимается разрешением зависимостей, в том числе и циклических;
 - оптимизация первого запуска приложения (при открытии веб-страницы браузер подгружает только нужные скрипты; необходимые зависимости так же можно подгружать через условные конструкции).

### Недостатки

При росте объема программного кода и числа модулей ухудшается пользовательский опыт, поскольку браузер должен подгружать множество файлов. Браузеры, до выхода протокола HTTP/2.0 могли поддерживать до 6 параллельных HTTP-соединений (https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Connection_management_in_HTTP_1.x). Под копотом HTTP использует TCP, а это значит, что расходуется время на установку соединение (трехстороннее рукопожатие), обмен ключами шифрования для установки защищенного соединения, а также медленный сарт TCP-соединения и постепенное увеличение объема пересылемых данных (https://habr.com/ru/companies/webo/articles/327050/).

В будущем эта проблема будет решена сборщиками (бандлерами), который объединяют множество модулей в один файл, что значительно сокращает количество запросов.

## ECMAScript-модули

В 2015 году вышла спецификация ES6, которая привнесла в JavaScript много нового и полезного функционала. К нему относится:
 - синтаксис классов (по сути это синтаксический сахар; изначально в языке отсутсвовала поддержка классов, однако реализовать их можно было на основе протипов);
 - ключевые слова <span class="variable">let</span> и <span class="variable">const</span> с блочной видимостью;
 - стрелочные функции;
 - интерполяция строк;
 - деструктуризация объектов.

Ну и конечно, нативная модульная система, которая поддерживается как в NodeJS так и внутри браузера. Давайте рассмотрим синтаксис импорта и экспорта объектов.

### Экспорт

Как и в случае с [CommonJS](#commonjs) ES-модули предлагают два вида экспорта: именованный и импорт по умолчанию:

```js
// module.js

// Именованный экспорт
export funation sum(a, b) {
    return a + b;
}

export class A {
    // тело класса
}

// Экспорт по умолчанию
export default function () {
    // тело функции
}
```

В случае ES-модулей экспорт имеет предсказуемое поведение. Модуль одновременно может иметь как именной так и дефолтный экспорт.

### Импорт

Инструкция импортов при работе с ES-модулями так же проста в применении.

Для импорта именованных объектов используется следующая конструкция:

```js
// index.js
import { sum } from 'module';

sum(1, 2)
```

Для использования дефолтного импорта:

```js
// index.js
import foo from 'module';

foo()
```

### Использование в браузере

Одной из особенностей инсрукции <span class="variable">import</span> является то, что зависимость можно указать в виде URL. То есть импорт в ES6 модулях является асинхронным, что очень хорошо для однопоточной браузерной среды. На сегодняшний день современные браузеры достаточно широко поддерживают ES-модули (https://habr.com/ru/companies/ruvds/articles/492510/).

Давайте посмотрим, как же можно работать с ES6 модулями. Пример находится здесь [ECMAScriptModules](./ECMAScriptModules/)

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <script type="module" src="./index.js"></script>
    </head>
    <body>

    </body>
</html>
```

У нас имеется наш HTML-документ, который подключает index.js. Заметьте, что для поддержки ES-модулей в браузере необходимо задать атрибут <span class="variable">type</span> со значением <span class="variable">module</span>. Иначе браузер будет воспринимать этот код как обычный js-модуль.

Рассмотрим наши модули

```js
// module.js
export default function() {
    console.log("aboba");
}

export const sum = (a, b) => a + b;

// index.js
import foo, { sum } from './module.js';

foo();

console.log(sum(1, 2));
```

При запуске приложения мы видим, что был загружен index.js, который асинхронно подгружает module.js. Так же как и с [AMD](#amd-asynchronous-module-definition-модули) модулями, нам больше не приходится руками управлять подключением скриптов и разрешать зависимости. Браузер делает это все за нас. Однако важно помнить, что весь наш исходный код должен прилетать в браузер с того же домена, что и сама страничка, иначе будут проблемы с политикой CORS. За предоставление пользователям доступа к статике отвечает веб-сервер, на котором мы будем размещать наши ресурсы.

### Использование в NodeJS

Использование в NodeJS абсолютно такое же как и в браузере, за тем исключением, что каждая среда по-своему может реализовать свой загрузчик скриптов. В случае NodeJS загрузка происходит синхронно.

### Достоинства

 - нативная поддержка в современных браузерах;
 - автоматическая загрузка скриптов и разрещение зависимостей;
 - удобный и понятный в использовании синтаксис;
 - хорошо оптимизируется бандлерами (об этом будем говорить позже);

### Недостатки

 - охват браузерами хоть и широкий, но если ваши клиенты пользуются старыми браузерами вроде IE 11, которые не поддерживают современные модули, то придется прибегнуть к помощи транспиляторов и сборщиков;
 - необходимо поддержка протокола HTTP/2.0 в браузере, иначе возникнет проблема загрузки множества модулей, из-за чего может ухудшится пользвательский опыт;
 - отсутсвие минификации кода и tree shaking (код в браузер поступает в том виде, в котором он написан, а это может создавать нагрузку на сеть);
 - относительные пути в проекте (сборщики помогают организовать работы с импортами более удобным образом, помогая избегать конструкции вида "../../../../module.js")
 - необходимость самостоятельной обработки различных ресурсов (SASS, SCSS, поскольку бандлер позволяет встроить все инструменты в единый процесс сборки)

## Резюме

На заре веба, вероятно, наличие модулей не было острой необходимостью. Однако желание разработчиков создавать более сложные, отвечающие современным требованиям приложения спровоцировало развитие модульных систем языка JavaScript.

Каждая модульная система пыталась решить определенный ряд проблем. Долгое время в среди веб-разработчиков были популярны AMD-модули, которые до сих пор могут встретиться в старых проектах. Например, первая версия фреймворка Aurelia, для разработки реактивных приложений, использовала RequireJS. В последствии от нее отказались из-за появления новых инструментов.

Модульная система, описанная в спецификации ES6 в 2015 году, является стандартом разработки. Однако даже сегодня мы не можем говорить о ее полной поддержке. Дело в том что за каждой платформой стоит своя организация, отвечающая за ее сопровождение. Каждая организация в своем темпе реализует поддержку спецификации. А разработчик никогда не знает, с какими целевыми платформами ему предстоит столкнуться в своей деятельности.

По этой причине разработчикам веб-приложений, уже имеющим возможность работать с новой спецификацией языка, приходилось и приходится прибегать к дополнительным инструментам, позволяющим использовать современные фичи в старых браузерах. Об этих инструментах мы и будем говорить в следующей лекции. 

Так же поговорим о том, как работать с огромной базой CommonJS пакетов внутри ES-модулей.


## Ссылки

1. [Node.js и JavaScript для серверной разработки](https://habr.com/ru/companies/ruvds/articles/345164/)
2. [Крупные компании, использующие Node.js](https://habr.com/ru/companies/vdsina/articles/552008/)
3. [Документация RequireJS](https://requirejs.org/)
4. [Connection management in HTTP/1.x](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Connection_management_in_HTTP_1.x)
5. [Внутренние механизмы ТСР, влияющие на скорость загрузки: часть 2](https://habr.com/ru/companies/webo/articles/327050/)
6. [ES6-модули в браузере: готовы они уже или нет?](https://habr.com/ru/companies/ruvds/articles/492510/)
