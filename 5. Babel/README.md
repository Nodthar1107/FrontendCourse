# Траснпиляция, полифилы и преобразование модулей

В этой статье рассматривается достаточно важный инструмент, который долгое время использовался фронтенд-разработчиками (и не только) для повышения качества кодовой базы своих проектов. Он позволял обойти проблему необходимости поддерживать проект под различные платформы и сильно упрощал жизнь, поэтому здесь мы познакомимся с этим инструментов, предпосылками его появления и сценариями его использования. Эта статья логически вытекает из [предыдущей](../JsModules/README.md), подчеркивая важность понимания, что в мире JS существует множество модульных систем, с которыми мы должны уметь работать. И чтобы закрепить этот материал, а также познакомиться с возможностями рассматриваемого инструмента, мы разберем реальную проблему и обойдем ее новыми средствами.   

## Транспиляция и Babel

Первое, о чем будем говорить сегодня - транспиляция. На прошлой лекции мы обсудили, что платформ, исполняющих JavaScrip достаточно много, и их поддержкой занимаются различные организации. По этой причине поддержка новых фич может появиться значительно позже выхода новой спецификации языка, из-за чего современный код на такой платформе будет нерабочим. Однако разработчикам уже хочется использовать свежие возможности, которые могут упростить процесс разработки.

Что же делать в такой ситуации? На помощь разработчикам приходит такой инструмент как [Babel](https://babeljs.io/docs). Babel является транспилятором, который позволяет преобразовать современный синтаксис ES6+ спецфикаций в ES5. ES5 спецификация считается наиболее широко поддерживаемой, поэтому в качестве целевой спецификации используется именно она.

### Описание тестового проекта

Стандарт ES6 добавил добавил такие синтаксические возможности как определеные классов и стрелочных функций, блочные переменные и константы, шаблонные литералы, нативные промисы и многое другое. Ссылка на перечень нововведений [Обзор базовых возможностей ES6](https://habr.com/ru/articles/313526/).

Давайте рассмотрим простое NodeJS приложение [TransformSyntax](./TransformSyntax/). В нем содержится несколько файлов, описанных в формате [CommonJS](../JsModules/README.md#commonjs).

Следующий листинг содержит определение стрелочной функции а также ее экспорт.

```js
// arrow-function.js
const sum = (a, b) => a + b;

module.exports.sum = sum;
```

В следующем листинге идет описание простого класса, содержащего два приватных поля (обозначаются через #), конструктор, набор геттеров, а также метод setProperty, устанавливающий свойства по ключу в state. Далее класс экспортируется.

```js
// classes.js
class Application {
    #name;
    #state;
    
    constructor(name, initialState = {}) {
        this.#name = name;
        this.#state = initialState;
    }

    getName() {
        return this.#name;
    }

    getProperty(name) {
        return this.#state[name];
    }

    setProperty(name, value) {
        this.#state[name] = value;
    }
}

exports.Application = Application;
```

Далее приводится содержимое index.js, в котором демонстрируется использование класса и стрелочной функции.

```js
// index.js
const sum = require('./arrow-function').sum;
const Application = require('./classes').Application;

console.log(sum(1, 2));

const application = new Application('my-app')

application.setProperty('heapSize', 4096);
application.setProperty('restartOnFail', true);

console.log(application.getProperty('heapSize'));
console.log(application.getProperty('restartOnFail'));
console.log(application.getProperty('processId'));
```

Если мы запустим это приложение из под современной ноды, то никаких проблем с исполнением кода не испытаем. При запуске командой:

```bash
node ./src/index.js
```

получим следующий результат в консоли (для каждого вывода для удобства подписал строки, которые выводят сообщения):

```js
3 // console.log(sum(1, 2));
4096 // console.log(application.getProperty('heapSize'));
true // console.log(application.getProperty('restartOnFail'));
undefined // console.log(application.getProperty('processId'));
```

Теперь, давайте попробуем запустить этот код на старой версии NodeJS, которая еще не поддерживала ES6. Для демонстрации я скачал установщик версии 5.12.0 с официального сайта [nodejs (v5.12.0)](https://nodejs.org/en/download/archive/v5.12.0). После установки в моем случае переменные окружения не были добавлены, что мне на руку, поскольку я использую менеджер зависимостей nvm.

Давайте попробуем запустить проект. Перейдем в папку с установленной старой версией NodeJS и попробуем запустить проект:

```bash
путь\к\nodejs>node.exe "путь\к\src\index.js"
```

В результате увидим примерно вот такие сообщения с описанием синтаксических ошибок:

```cmd
SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode

function Application(name, initialState = {}) {
                                          ^
SyntaxError: Unexpected token =
```

Видим, что среда не может запустить приложение с новым синтаксисом.

### Настройка .babelrc

Мы столкнулись с реальностью, в которой долгое время жили фронтенд разработчики (хотя и демонстрацию проводим в другой среде, но это не важно). К счастью для нас сообщество разработчиков создало такой инструмент как Babeljs. Последовательность действий babeljs выглядит следующим образом:
 1) загрузка исходников js-файлов;
 2) построение модели исходного текста, называемой абстрактным синтаксическим древом (далее поговорим об этом чуточку подробнее);
 3) последовательное применение логики плагинов, которые преобразуют исходный ES6+ код в эквивалентный ES5;
 4) обратное преобразование синтаксичского дерева в исходный код и вывод в файлы целевой директории.

Прежде всего необходимо осуществить глобальную установку babeljs, чтобы мы могл запускать его из командной строки. Процесс установки описан [здесь](https://babel.dev/docs/usage). Каждый используемый плагин так же необходимо будет установить в devDependencies проекта.

Чтобы мы могли осуществить преобразования синтаксиса, необходимо завести файл конфигурации .babelrc (этот файл может так же называться babel.config.json). Конфигурация babel описывается в формате json. В гайде указано, что такой формат используется для одного сценария транспиляции приложения, однако логика преобразования может быть достаточно сложной, управляемой различными параметрами, например, из окружения. Для этого конфигурация описывается в файле babel.cofig.js.

В рамках этого урока нам достаточно описать простой сценарии транспиляции. Конфиг babeljs предоставляет достаточно много опций, например, минификация кода и его сжатие (удаление лишних символов, чтобы уменьшить размер файлов). Для нашей задачи мы воспользуемся только опцией plugins, которая позволяет подключить все необходимые плагины.

Результирующий конфиг приведен в следующем листинге:

```json
{
  "plugins": [
    "@babel/plugin-transform-arrow-functions",
    "@babel/plugin-proposal-class-properties",
    "@babel/plugin-transform-classes",
    "@babel/plugin-transform-block-scoping",
    "@babel/plugin-transform-parameters"
  ]
}
```

Многие плагины можно найти на сайте документации. Теперь, чтобы запустить транспиляцию проекта необходимо запустить babel со следующими опциями:

```bash
babel src --out-dir dist
```

где src - путь к исходникам, а --out-dir dist - именной параметр с указанием выходной директории.

Так же эту команду можно добавить в package.json в раздел scripts:

```json
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "babel src --out-dir dist"
}
```

Таким образом, через командную строку можно будет запускать простую команду, не запоминая особенностей babe-cli.

```bash
npm run build
```

В результате вызова одной из этих команд, мы получим преобразованный к синтаксису ES5 (при желании можно почитать исходники). Теперь давайте запустим транспилированное приложение через NodeJS v5.12.0.

```bash
путь\к\nodejs>node.exe "путь\к\dist\index.js"
```

В результате увидим, что наш код заработал в старой среде. Однако такого рода конфигурация может показаться достаточно неудобной, поскольку нам необходимо руками прописывать все нужные нам плагины, а иногда даже следить за их порядком подключения. Так, например, порядок подключения следующих плагинов важен, иначе babel упадет с ошибкой:

```
@babel/plugin-proposal-class-properties
@babel/plugin-transform-classes
```

### Babel Presets

Чтобы решить описанную выше проблему, babel предоставляет набор пресетов. По сути это набор плагинов ES6+ версий. В них так же входит те плагины, которые мы использовали для транспиляции нашего кода. Каждый пресет содержит плагины для транспиляции исходного синтаксиса: typescript, jsx, flow и синтаксис языка JS. Давайте упрости нашу конфигурацию, подключив @babel/preset-env.

```json
{
    "presets": [
        "@babel/preset-env"
    ]
}
```

При повторном запуска скрипта build мы получим аналогичный резлуьтат.

### Использование @babel/core

Теперь давайте поговорим об абстрактном синтаксическом дереве, которое строит babel перед трансформацией синтаксиса. На самом деле многие технологии, занимающиеся обработкой текста, строят модели, удобные для дальнейшего анализа или преобразования. Так например, интерпретаторы языков высокого уровня, статические анализаторы, линтеры, все они использую AST (Abstract Syntax Tree).

Дерево представляет собой набор узлов. Для каждого узла задан его тип (например, VariableDeclaration или FunctionExpression) и набор соответсвующих этому типу свойств, характеризующих данный узел. Давайте построим AST простой функции. Для этого посмотри на проект [babel-core](./babel-core/).

Пакет @babel/core предоставляет нам набор некоторых функций, которые мы можем использовать в рантайме нашего приложения для построения AST деревье
Рассмотрим слдующий скрипт:

```js
import fs from 'fs';
import { parseSync, transformFromAstSync } from '@babel/core';

const moduleContent = fs.readFileSync('./demo-module.js').toString();
console.log(moduleContent);

const ast = parseSync(moduleContent);
console.log(ast);

const tranformed = transformFromAstSync(ast);
console.log(tranformed.code);
```

Вывод в консоли будет недостаточно понятный, поскольку строковое представление узла Node выглядит как [ Node ], поэтому придется углубляться (для каждого узла использовать console.log). Чтобы более наглядным образом познакомиться с моделью нашей программы, можно воспользоваться этим сайтом https://astexplorer.net/. Здесь можно раскрыть каждый узел и детально изучить структуру дерева.

Далее для этого дерева можно осущствить обратное преобразование, превратив его в код. В результате мы увидим, что он совпадает с нашей иходной функцией.

### Кастомный babel-плагин

Теперь давайте посмотрим, как на базе babel можно реализовать свой собственный плагин, работающий с деревом. Часто на проектах бывает такая проблема, что люди забывают удалить отладочный вывод, который в итоге засоряет логи в рантайме приложения. Такие выводы не несут ценности для проекта, поэтому они должны быть вычищены из кода. Для этого обратимся к проекту [babel-plugins](./babel-plugin/).

Рассмтрим следующий исходный код:

```js
// module.js
export function sum(a, b) {
    console.log('Arg a: ', a);
    console.log('Arg b: ', b);

    return a + b;
}

// index.js
import { sum } from './module.js';

const result = sum(1, 2);

console.log(result);
```

Код приложения в некоторых местах содержит вызовы метода log объекта console. Чтобы они нам никогда не мешали в прод-сборке приложения, мы можем написать свой собственный babel-плагин. Выглядеть он будет следующим образом:

```js
export default function() {
    return {
        visitor: {
            CallExpression(path) {
                const { callee } = path.node;
                
                // Проверяем, является ли callee MemberExpression с console.log
                if (
                    callee.type === 'MemberExpression' && 
                    callee.object?.name === 'console' && 
                    callee.property?.name === 'log'
                ) {
                    path.remove();
                }
            }
        }
    }
}
```

По сути плагин это функция, которая возвращает некоторый объект с полем visitor. Все плагины, используемые babel реализуют паттерн [Посититель](https://refactoringguru.cn/ru/design-patterns/visitor). Объект содержит набор некоторых функци обработчиков, которые вызываются для узлов соответсвующего типа. Каждый обработчик имеет параметр path, который является оберткой поверх объекта node (узла дерева). Она предоставляет набор методов по манипуляции над этим узлом в дереве, например, удаление из дерева, вставить перед или после и другие.

В рамках нашей задачи нам необходимо определить обработчик такого узла как CallExpression, ведь запись console.log непосредственно и является вызываемым выражением. Тип узла, описывающего вызов этой функции как раз будет CallExpression (можно проверить на сайте https://astexplorer.net/). Теперь нам необходимо убедиться, что CallExpression действительно является выводом в консоль. Для этого опишем условие для узла. Если оно верное, то для path вызовется метод remove.

Конфигурация babelrc будет выглядеть следующим образом:

```json
{
    "plugins": [
        "./plugins/remove-logs.js"
    ]
}
```

В plugins указываем путь к нашему плагину.

В результате работы babel получаем наши модули с удаленными выводами в консоль. Таким образом можно разрабатывать плагины любой сложности для решения любых задач обработки исходного кода. Не факт, что вам предстоит писать собственные плагины, но на этом примере у вас сложится представление, как работает Babeljs и использующие подобные алгоритмы инструменты, например, eslint. В своей практике мне приходилось писать плагины, обрабатывающие AST-узлы, построенны для MD-документов. Теперь и вы без проблем справитесь с похожими задачами.

Одной из популярных библиотек для построения AST-деревьев на основе произвольного текста - [unified](https://unifiedjs.com/explore/package/unified/). Она, работает по тем же принципам, что и babel и позволяет преобразовывать языковые форматы в любые другие, например, markdown в HTML.

### Babel Polyfills

Мы рассмотрели сценарий использования babel, который позволяет нам использовать современный синтаксис. Однако новые спецификации помимо этого нередко привносят в язык и новый API. В спецификации ES6 появились нативные Promise(-ы), которые позволяют реализовать асинхронную логику (полезная статья про Promise https://habr.com/ru/companies/vk/articles/269465/). Тем не менее в ES5 была возможность использования промисов библиотечных реализаций. Например, Angular предоставлял собственные Promise(-ы). Соответственно с появлением ES6 в языке появились типы и набор методов для работы с ними.

Из других нововведений, в ES6 появились новые методы для работы с уже существовавшими массивами, например, метод includes.

Что же делать, если среда исполнения не поддерживает новые официальные типы и не предоставляет реализацию для методов существующих типов? Для метода includes, например, можно предоставить эквивалентную ему реализацию:

```js
Array.prototype.includes = function(obj) {
    return this.indexOf(obj) !== -1
}
```

Таким образом устроен плагин babel-plugin-transform-array-prototype-includes, который в прототипе массива определяет реализацию метода.

В случае с Promise(-ми) решение будет чуточку сложнее. Для реализации функциональности отсутвующего API в старых версиях Babel использует полифилы. Наиболее популярная библиотека с полифилами - [core-js](https://www.npmjs.com/package/core-js). Она содржит логику, которая определяет функциональность, отсутсвующую в старом стандарте.

Для того же метода includes core-js предоставляет полифил `es.array.includes`, который содержит следующий код:

```js
// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});
```

Теперь давайте попробуем настроить конфигурацию .babelrc для среды NodeJS 5.12.0, где поддержка Promise и includes точно отсутвует. Для демонстрации можно воспользоваться проектом [babel-polyfills](./babel-polyfills/).

Лиcтинг с описанием конфигурации .babelrc:

```json
{
    "presets": [
        [
            "@babel/preset-env",
            {
                "useBuiltIns": "usage",
                "corejs": "3.45.1",
                "modules": "commonjs",
                "targets": {
                    "node": "5.12.0"
                }
            }
        ]
    ]
}
```

В этом листинге мы также используем плагин @babel/preset-env, который можно сконфигрировать. Массив presets устроен таким образом, что он умее тобрабатывать как строки, так и массивы из двух элементов, которые описывают пресет и набор его опций.

Среди опций этого плагина указана целевая платформа, модульная система для выходных файлов, версия библиотеки core-js, из которой берется реализация всех полифилов, а также опция useBuildIns, которая принимает одно из трех значений:
 - `'usage'` подставляет полифилы на основе анализа кода (подставляем только то, что непосредственно используем в модуле);
 - `'entry'` импортирует всю библиотеку core-js в entry-файл приложения (в нашем случае index.js);
 - `false` - не подставляет полифилы вовсе.

Каждая опция оправдана при определенных сценариях. В нашем случае приложение маленькое, поэтому воспользуемся опцией `'usage'`. Теперь давайте посмотрим на исходный код:

```js
// promises.js
export const somePromise = (value, timeout) => {
    return new Promise((resolve) => {
        console.log('Before timeout: ', performance.now());

        setTimeout(() => {
                console.log("After timeout: ", performance.now())

                resolve(value);
            },
            timeout
        );
    })
}

// index.js
import { somePromise } from './promises.js';

const array = [1, 2, 3];
console.log(array);
console.log("Includes 1", array.includes(1));

somePromise({ status: 200, applicationIds: [1, 2, 3] }, 2000)
    .then((value) => {
        console.log('Resolved value', value);
    })
    .catch((error) => {
        console.log(error)
    })
    .finally(() => {
        console.log('Finally section');
    });
```

В этом листинге имеем два модуля. promises.js описывает некоторую функцию, возвращающую promise по тайм-ату. index.js демонстрирует использование метода includes, а также вызывает somePromise из promises.js.

Запустим скрипт сборки `npm run build` и посмотрим на результат.

```js
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.somePromise = void 0;
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
var somePromise = exports.somePromise = function somePromise(value, timeout) {
  return new Promise(function (resolve) {
    console.log('Before timeout: ', performance.now());
    setTimeout(function () {
      console.log("After timeout: ", performance.now());
      resolve(value);
    }, timeout);
  });
};
```

В начале модуля видим строчки `Object.defineProperty`, но нам они сейчас мало интересны. А вообще говоря это результат преобразования ES-модуля в [CommonJS](../JsModules/README.md#commonjs). Таким образом транспилятор помечает этот модуль как бывший нативный ES-модуль. Так жем мы видим, что в модуле появился импорт из `core-js`, который добавляет реализацию для Promise(-ов) (и еще какую-то функциональность).

Для index.js:

```js
"use strict";

require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.promise.finally.js");
var _promises = require("./promises.js");
var array = [1, 2, 3];
console.log(array);
console.log("Includes 1", array.includes(1));
(0, _promises.somePromise)({
  status: 200,
  applicationIds: [1, 2, 3]
}, 2000).then(function (value) {
  console.log('Resolved value', value);
}).catch(function (error) {
  console.log(error);
}).finally(function () {
  console.log('Finally section');
});
```

Здесь мы видим похожую картину с импортом из `core-js`.

Теперь давайте попробуем запустить наш проект в старой среде NodeJS. Сначала запустим исходный проект

```cmd
(function (exports, require, module, __filename, __dirname) { import { somePromise } from './promises.js';
                                                              ^^^^^^

SyntaxError: Unexpected token import
```

Увидим, что среда ругается на наличие `import`, который еще не поддерживается в этой среде. Удаление импорта из исходного модуля так же приведет к ошибке, но уже связанной с использованием includes:

```cmd
console.log("Includes 1", array.includes(1));
                                ^

TypeError: array.includes is not a function
```

Теперь давайте запустим преобразованный код и посмотрим на результат:

```cmd
[ 1, 2, 3 ]
Includes 1 true
Resolved value { status: 200, applicationIds: [ 1, 2, 3 ] }
Finally section
```

Видим, что наш код успешно работает в более старой среде NodeJS! Таким образом, мы познакомились с полифилами и научились их использовать в проектах с совремнными инструментами и синтаксисом.

### Преобразование модульных систем

Еще одна тема, которой хотелось бы коснуться - преобразование модульных систем при помощи babel. В предыдущем разделе мы уже немного обсудили этот вопрос, когда добавили полифилы в сборку проекта. Там мы увидели, что пресет @babel/preset-env в своих опциях позволяет настраивать целевую модульную систему. Однако я бы хотел рассмотреть еще одну задачку, связанную с пониманием устройства модульных систем.

Давайте рассмотрим такую задачу. Предположим для разработки проекта мы решили воспользоваться фреймворком, который имеет собственную систему плагинов. Фреймворк используется для сборки приложения, поэтому нам понадобится скрипт `build` в [package.json](./babel-transform-modules/package.json), запускающий процесс сборки. Фреймворк подтягивает пользовательские плагины и запускает их в процесс сборки. Подключение плагинов осуществляется в файле [engine.config.js] в вид путей к плагинам.

Для демонстрации проблемы и ее решения будет использоваться проект [babel-transform-modules](./babel-transform-modules/).

Чтобы движок мог запустить плагин, он должен соответствовать контракту: модуль должен использовать дефолтный эскпорт для функции, которая принимает объект с опциями фреймворка.

Сам движок использует модульную систему [CommonJS](../JsModules/README.md#commonjs).

Структура проекта:
 - engine/index.js - код фреймворка, отвечающий за загрузку плагинов и их вызов;
 - plugins - директория с пользовательскими плагинами
  - plugins/commonjs-default-export.js - commonjs модуль, с дефолтным экспортом функции
  - plugins/es-default-export.mjs - ES-модуль, с дефолтным экспортом функции
 - src - папка с исходным кодом приложения.
 - engine.config.js - файл конфигурации движка

В проекте так же имеется package.json файл, где описаны команды для запуска примера:
 - `npm run build:plugins` запускает транспиляцию плагинов из папки plugins (результат транспиляции помещается в dist/plugins);
 - `npm run build` запускает транспиляцию плагинов и далее запускает скрипт engine/index.js, использующий плагины из dist/plugins

В прошлом уроке мы с вами выяснили, что на сегодняшний день мы имеем две наиболее популряные модульные систем: [CommonJS](../JsModules/README.md#commonjs) и ES. Мы столкнулись с тем, что движок написан с использованием commonjs-модулей. Кроме того, он ожидает, что плагины так же будут описаны с помощью commonjs с дефолтным экспортом функции. Это значит, что при загрузке модуля с помощью `require` в результате будет получена функция. Однако мы как разработчики можем захотеть использовать ES-модуль и дефолтный экспорт. Так как движок работает с модульной системой [CommonJS](../JsModules/README.md#commonjs), то нам необходимо преобразовать наш ES-модуль. Сделать это можно с помощью babel-конфигурации из прошлого раздела (смотри [Babel Polyfills](#babel-polyfills)).

Исходный код плагина:

```js
export default function(engineOptions) {
    console.log('Inside ES-module');
    console.log('Engine options', engineOptions);
}
```

В результате ES-модуля получим следующий код:

```js
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
function _default(engineOptions) {
  console.log('Inside ES-module');
  console.log('Engine options', engineOptions);
}
```

Да, мы получили CommonJS-модуль, но работать с ним получится только следующим образом:

```js
const plugins = require('transpiled-es-default-export.js');

plugins.default(); // Ожидается вот так: plugins()
```

То есть мы получили модуль таким, как если бы экспорт выглядел следующим образом:

```js
module.exports.default = function {
    // Тело функции
}
```

Это не соответсвует контракту плагина, и при запуске процесса сборки мы получим ошибку вызова плагина. Теперь, зная проблему, и имея систему плагинов babel, мы можем иправить ситуацию и настроить сборку плагинов таким образом, чтобы разработчиким могли писать с использованием любой модульной системы, которая им нравится. Для этого можно воспользоваться плагином с длинными названием `babel-plugin-transform-es2015-modules-commonjs-simple`, который распаковывает `default`-экспорт, делая код совместимым с логикой движка.

Конфигурация .babelrc:

```json
{
    "plugins": [
        [
            "babel-plugin-transform-es2015-modules-commonjs-simple",
            {
                "noMangal": true,
                "addExports": true
            }
        ]
    ]
}
```

В результате имеем следующий код:

```js
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = function (engineOptions) {
  console.log('Inside ES-module');
  console.log('Engine options', engineOptions);
};
module.exports = exports['default'];
```

Теперь экспортируемый модуль представляет собой функцию. В результате имеем рабочую систему плагинов, способную обрабатывать две модульные системы. А мы рассмотрели еще один случай трансиляции, который может быть полезен в вашей работе.

## Резюме

В этой статье мы познакомилсь с таким важным инструментом как Babel. Изучили сценарии его применения и соответсвтенно попробовали применить его для решения собственных задач. Babel мощный инструмент, полезность которого сложно переоценить, поскольку он был мостом между старыми и современными технологиями. Однако сейчас его роль постепенно меняется. Если раньше он был стандартом разработки, делая технологию необходимой к применению на каждом проекте, то сейчас он используется для решения специфических задач. На смену ему приходят новые технологии транспиляции, такие как SWC, написанный на Rust, ts-compiler, для языка TypeScript. Однако Babel на данный момент имеет большее сообщество и более обширную систему плагинов.

Далее мы познакомимся с инструментами сборки приложений на основе сборщика модулей Webpack. Webpack на сегодняшний день является стандартом разработки. Умение работать с ним позволит вам осуществлять сборку разрозненных модулей в единый бандл, оптимизировать процесс доставки кода клиенту, разбивая его на чанки, повысить качество работы с зависимостями в коде, а также использовать полезные инструменты как CSS-modules, Sass, минификаторы кода и прочие. Кстати, Webpack так же умеет работать с Babel, который используется как загрузчик JS-кода и транспилятор.
