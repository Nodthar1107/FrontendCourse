# Обзор современных frontend-фреймворков

На прошлой лекции мы поговорили об истории развития Web-технологий, проследили как меняется Web-архитектура WWW, распределяются функции между участниками клиент-серверного взаимодействия и немного поговорили о современных фреймворках для разработки веб-приложений. Сегодня я бы больше хотел остановиться API этих фреймворков, показать синтаксис шаблонов, как управлять потоками данных, показать некоторые нетривиальные примеры и прокомментировать, какие сложности могут возникнуть при выполнении некоторых задач.

## Анонс участников

В этом уроке я бы хотел провести демонстрацию работы с 4-мя фреймворками (неожиданно, не правда ли?). Помимо тройки лидеров (Angular, React и Vue) я бы хотел так же показать еще один фреймворк - AureliaJS. Это весьма необычный фреймворк с интересной философской позицией. На мой взгляд он очень похож на Angular, однако в некоторых аспектах работа с ним кажется более простой.

## Компонентный подход

Первое о чем бы хотелось поговорить - это компонентный подход (неплохая статья о том, что такое компонент и как их описывать [Компонентный подход в вёрстке: подробный разбор для джунов и сочувствующих](https://habr.com/ru/companies/yandex_praktikum/articles/748794/)). Каждый фреймворк использует его определенным образом. Что же такое компонент? Компоненты это самостоятельные UI-элементы на веб-странице, из которых строится интерфейс приложения. Каждый компонент описывает то, как он выглядит, с какими данными он может работать и описание некоторой логики, работающей с этими данными. Давайте посмотрим, как это выглядит в каждой из технологий.

## Обзор возможностей библиотеки React

React - это библиотека, позволяющая реализовать View-слой клиентского приложения. Компоненты на React полностью описываются на языке JavaScript в виде функций, возвращающих некоторую разметку, или классов, реализующих методы жизненного цикла компоненты. Описание компонент осуществляется в файлах с расширением .jsx. Это специальный формат файла, который добавляет подсветку к специальному синтаксису описания компонент - JSX. Этот синтаксис внешне очень напоминает HTML, однако он представляет собой синтаксический сахар, который в результате компиляции превращается в набор функций API React, создающие ReactNode объекты. На их основе потом строится DOM-дерево.

### Синтаксис JSX

Давайте посмотрим, как же выглядит JSX разметка:

```jsx
<article>
    <h1>My First Component</h1>
    <ol>
        <li>Components: UI Building Blocks</li>
        <li>Defining a Component</li>
        <li>Using a Component</li>
    </ol>
</article>
```

В этом примере вы можете увидеть использование стандартных HTML тегов. Заголовок, нумерованный список и элементы списка.

```jsx
<div
    className='bg-black'
    style={{
        width: '400px',
        height: '200px',
        color: 'white'
    }}
    onClick={(e) => handleEvent(e)}>
    Какой-то текст...
</div>
```

В следующем примере можно увидеть нечто, напоминающее атрибуты. `ClassName` - аналог атрибута `class`. Он определен для любого стандартного HTML-элемента.  Переименование произошло по той причине, что слово `class` в языке зарезервировано. `style` - позволяет задать inline-стили для компонента. `onClick` - обработчик, вызываемый при клике на компонент (соответствует стандартному атрибуту `onclick`). Сейчас стоит пояснить, что на самом деле любой JSX-элемент является вызов функции API библиотеки React - `React.createElement`. При транспиляции этого кода мы получим следующую конструкцию:

```js
React.createElement('div', {
        className: 'bg-color',
        style: {  width: '400px', height: '200px', color: 'white' },
        onClick: (e) => handleEvent(e)
    },
    'Какой-то текст...'
);
```

То есть под капотом React создает элемент, который является блоком `div`. Этот элемент будет иметь некоторые свойства, описываемые объектом, переданным во втором параметре. Этот объект есть `props` компонента. `props` это набор свойств, с которыми умеет работать компонент. Те JSX-элементы, которые преобразуются в стандартные HTML элементы имеют стандартизированный набор `props(-ов)`. К ним относятся атрибуты соответствующих HTML-элементов, набор обработчиков, data-атрибуты и другие. Текстовые значения можно передать напрямую через знак `=`:

```jsx
<div className='some-class' />
```

Если `props` должен быть каким-то объектом, например, `style`, то значение устанавливается через `{}`:

```jsx
// Вариант 1
const style = {
    width: '400px',
    height: '200px',
    color: 'white'
};

<div style={style} />

// Вариант 2
<div style={{
        width: '400px',
        height: '200px',
        color: 'white'
    }}
/>
```

Почему во втором примере используем двойные фигурные скобки? Внешние скобки нужны, так как `style` должен быть объектом, а через внутренние скобки создаем сам объект. То есть здесь мы создаем объект по месту его использования - при передаче в качестве `props(-a)`.

Вообще говоря, фигурные скобки в JSX используются в том случае, когда мы хотим подставить JavaScript код. Константный объект `style` является JavaScript объектом. Мы хотим объект передать в `prop-style`. Так как `style` это JavaScript-объект, его необходимо обернуть в скобки.

Еще один пример:

```jsx

const isRed = false;

<div className={isRed ? "background-red" : "background-green"} />
```

В этом примере мы используем тернарный оператор, чтобы передать значение в `className`. Зафиксируем: в фигурных скобках мы можем писать любой JavaScript код, который возвращает некоторое значение или объект. В этом примере так как `isRed` есть `true` тернарный оператор вернет `"background-red"`.

Кроме стандартных элементов мы также можем описывать собственные компоненты и определять для них собственный список `props`, которые будут влиять на представление компоненты в интерфейсе.

### Пример простых компонент

React предоставляет два вида синтаксиса описания компонент: классовый и функциональный (в виде функций). В первых версиях React функциональные компоненты представляли собой чистые функции, которые возвращали только JSX-разметку. Классовые в свою очередь могли работать с состоянием, а также для них можно было определить набор методов, вызываемых на различных стадиях жизненного цикла. Давайте посмотрим, как можно описать компонент каждым из способов:

Функциональный компонент, описывающий карточку:
```jsx
import './style.css';

export const CardAsFunction = ({ title, description, img = undefined, alt = undefined, ...props }) => {
    return (
        <div className='card'>
            <div className='card__header'>
                {title}
            </div>
            {img
                ? <img className='card__image' src={img} alt={alt} />
                : <div className='card__default-image' />
            }
            <div className='card__description'>
                {description}
            </div>
        </div>
    );
}
```

Классовый компонент, описывающий карточку:
```jsx
import { Component } from 'react';

import './style.css';

export class CardAsClass extends Component {
    render() {
        const { title, description, ...props } = this.props;

        return (
            <div className='card'>
                <div className='card__header'>
                    {title}
                </div>
                {this.renderImg()}
                <div className='card__description'>
                {description}
            </div>
        </div>
        );
    }

    renderImg() {
        const { img = undefined, alt = undefined } = this.props;

        return img
            ? <img className='card__image' src={img} alt={alt} /> 
            : <div className='card__default-image' />;
    }
}
```

Давайте немного детальнее посмотрим на эти листинги. В случае функционального компонента мы объявили функцию, которая принимает некий объект, который мы разбираем по свойствам при помощи оператора деструктуризации. Давайте проиллюстрируем ее:

```js
const someObject = {
    property1: 'value1',
    property2: 'value2',
    ...,
    propertyN: 'valueN'
};

const { property1, property2, ...others } = someObject;

console.log(property1, property2, others, others.propertyN);
```

В этом примере мы определили объект с набором свойств. С помощью оператора деструктуризации мы можем извлечь из объекта некоторые свойства по имени. Обратите внимание, что `property1` и `property2` это имена свойств объекта `someObject`. А все другие свойств (набор ключей и значений записываются в объект others). Обращаться к ним мы можем так же по ключу.

В наших примерах компонент мы делаем ту же самую операцию. Объект, который мы передаем в функцию представляет собой `props(-ы)` компонента. Некоторые `props(-ы)` могут быть обязательными, как `title` и `description`, другие - опциональными, как `img` и `alt`. В конце этой конструкции мы указали `...props`. Сюда помещаются другие `props(-ы)` переданные в нашу компоненту, и мы с ними можем работать.

Далее в нашем функциональном компоненте идет описание возвращаемого JSX. Мы используем элементы `div` для которых задан атрибут `className`.

Во втором листинге с классовым компонент мы объявляем класс, который наследуется от `Component`. Любой классовый компонент должен наследоваться от него. Этот класс предоставляет нам метод `render`, который вызывается при отрисовке компонента. Класс `Component` предоставляет и другие методы, но об этом будем говорить в других уроках. В классовых компонентах `props(-ы)` доступны как поля класса через конструкцию `this.props`. Этот объект так же как и в функциональных компонентах можно деструктуризировать.

Как видно из листингов, функциональный компонент выглядит более компактно, поскольку не приходится использовать наследование и определять метод render. Однако оба компонента возвращают один и тот же JSX. Каждая их этих компонент импортирует стили из файла `style.css`. Другое достоинство функциональной компоненты - явное указание набора пропсов.

### Использование кастомных компонент в JSX

Как правило карточки на веб-странице предстают не в единственном экземпляре, поэтому давайте определим компоненту `Cards`:

```jsx
import './style.css';

export const Cards = ({ children, ...props }) => {
    return (
        <div className='cards'>
            {children}
        </div>
    );
}
```

Выглядит она очень простым образом. Обратите внимание, что в составе `props(-ов)` есть `children`. Это специальный `props`. Далее мы увидим, за что он отвечает. Давайте попробуем отрисовать наши карточки в списке `Cards`:

```jsx
import { CardAsClass } from './Card/CardAsClass';
import { CardAsFunction } from './Card/CardAsFunction';
import { Cards } from './Cards';

const cardDescription = [
    {
        title: 'Заголовок 1',
        description: 'Описание'
    },
    {
        title: 'Заголовок 2',
        description: 'Длинное описание'
    },
    {
        title: 'Заголовок 3',
        description: 'Очень длинное описание'
    },
    {
        title: 'Заголовок 4',
        description: 'Очень оооочень длинное описание'
    }
]

export const App = () => {
    const cardsFromClasses = cardDescription.map((card, index) => {
        return <CardAsFunction title={card.title} description={card.description} key={index} />;
    });

    const cardsFromFunctions = cardDescription.map((card, index) => {
        return <CardAsFunction title={card.title} description={card.description} key={index} />;
    }); 

    return (
        <Cards>
            {cardsFromClasses}
            {cardsFromFunctions}
        </Cards>
    );
}
```

В этом примере мы видим, что мы можем использовать наши карточки и список карточек как HTML-тэги. Если мы не прокидываем дочерние элементы в компонент, то мы можем использовать конструкцию непарного тэга. Если же прокидываем, как в случае с `Cards`, то используем парный тэг.

Мы завели массив объектов, которые описывают карточки. На основе этих данных мы создали два массива, вызовом метода `map`. Первый - карточки, в основе которых лежат классы, второй - функции. Оба массива мы передаем как дочерние элементы в компоненту `Cards`. И вот теперь мы можем вернуться к пропсу `children` компоненты `Cards`. Этот пропс всегда имеет такое имя, и в него попадает все то, что мы передаем в качестве дочерних элементов этого компонента. Следующая конструкция будет эквивалента нашему:

```jsx
<Cards children={[...cardsFromClasses, ...cardsFromFunctions]} />
```

### Чуть более глубокое погружение в функциональные компоненты

С выходом версии 16.8 фокус разработчиков библиотеки и ее пользователей сместился в сторону функциональных компонент. Это связано с появлением хуков - специальных функций, которые позволяли на функциональных компонентах делать все то, что можно было делать на классах: управлять состоянием, заводить ссылки на DOM-элементы и пользовательские компоненты, описывать обработчики, вызываемые на различных этапах жизненного цикла и даже больше. От классовых компонент постепенно отказываются в сообществе, поскольку они считаются громоздкими с точки зрения их описания, а также новый API все больше завязывается на функциональные компоненты (с этим API проще работать, чем на классах). Однако в моей команде ими компонентами на классах активно пользуются, когда реализация компонента не является тривиальной. Использование классов позволяет писать более чистый код, разнося логику обновления состояния или отрисовки компонента на методы различных уровней абстракции. Это упрощает чтение компонент и облегчает рефакторинг. Функциональные компоненты (при правильном их описании) представляют из себя более компактный код.

Далее мы будем разбирать особенности React на функциональных компонентах.

#### Работа с состоянием

Зачем нужно состояние? Современные фронтенд-приложения это история про данные data-flow - поток данных, проходящий сквозь элементы приложения. От состава этих данных зависит то, каким будет интерфейс нашего приложения. Состояние как правило хранится в компонентах верхнего уровня приложения. Под верхним уровнем может пониматься какая-то самостоятельная панель на странице. От верхних уровней данные распространяются вниз к компонентам нижнего уровня, которые чаще всего представляют собой презентационные компоненты, которые не имеют состояния. Они принимают только пропсы и отображают элемент в соответствии с ними.

Давайте для демонстрации спроектируем компоненту поиска чата в мессенджере. Выделим набор компонент, которые нам понадобятся. Пойдем сверху вниз:

Виджет списка чатов в мессенджере:
 - строка-фильтр для фильтрации чатов (презентативная управляемая компонента);
 - компонента списка чатов (контейнерная компонента, группирующая элементы списка);
  - компонента элемента списка чатов (презентативная компонента)

Какое же состояние будет у нашего компонента:
1) Список чатов;
2) Текст в поле фильтрации чатов;
3) Индекс выбранного чата с клавиатуры.

Реализация примера представлена в проекте [react/components-demo](./react/components-demo/src/AppExample2.jsx).

Цель этого примера - показать возможное решение по реализации панели с элементами списка, которые можно фильтровать и по которым можно перемещаться с помощью клавиатуры. Сильно вдаваться в подробности сейчас не обязательно, поскольку в других лекциях будем разбирать аспекты библиотеки React. Единственное, что вы должны осознать - как React позволяет работать с состоянием в функциональных компонентах.

У меня есть компонента App в файле [AppExample2.jsx](./react/components-demo/src/AppExample2.jsx). В ней мы используем виджет [ChatWidget](./react/components-demo/src/components/ChatWidget/index.jsx), который описывает виджет списка чатов. Кроме этого, у нас есть компонента [ChatList](./react/components-demo/src/components/ChatList/index.jsx) и [ChatListItem](./react/components-demo/src/components/ChatListItem/index.jsx). Эти компоненты являются презентативными. Они только отображают переданные в них пропсы.

Внутри виджета `ChatWidget` в самом начале функции мы используем хук `useState`. С помощью него мы можем задать, какие переменные будут формировать состояние компонента. В нашем примере состояние состоит из следующих переменных:
 - `filterText` - текст в инпуте, по которому фильтруются чаты (начальное значение - `""`);
 - `keyboardSelectionIndex` - индекс выделенного элемента с клавиатуры (начальное значение `-1`, поскольку компонента реализована таким образом, что работа с клавиатурой осуществляется только тогда, когда инпут находится в фокусе)
 - `chats` - список чатов (начально значение - `[]`);
 - `isLoading` - флаг, который говорит, находится ли еще компонента в стадии загрузки контента(начальное значение - `true`)
 - `isLoadingError` - флаг, определяющий произошла ли ошибка в процессе загрузки (начальное значение - `false`)

Оперируя этим состоянием, мы определяем то, каким образом будет представлен UI нашего виджета.

Хук `useState` при вызове возвращает массив из двух элементов: текущее состояние конкретной переменной (или при первом рендере компоненты значение инициализации) и функцию, которая позволяет обновить значение этой переменной. При вызове этого хука мы также пользуемся оператором деструктуризации. Только в этом случае мы в переменные присваиваем элементы массива. При вызове функции обновления переменной с новым значением (ссылкой на новый объект) React вызывает повторно функцию нашего компонента и перерисовывает UI с новыми данными.

Далее по коду видим `useRef`. Этот хук используется в двух сценариях. В нашем примере `useRef` позволяет сохранить некоторое состояние между вызовами функции. В нашем примере использованием обоих хуков чем-то похоже. Оба хука позволяют сохранить значения переменных между вызовами функционального компонента. Однако если мы хотим, чтобы при изменении значения переменной компонент обновлялся, то мы используем `useState`. Если мы хотим менять значение переменной, но перерисовок не происходило, то мы используем `useRef`.

Вообще говоря, `useRef` возвращает объект-обертку:

```js
const wrapper = {
    current: ourValue
}
```

Доступ к нашим данным доступен через свойство `current`.

Далее мы описываем обработчики, которые будут слушать события поля ввода: `handleInputChange` и `handleKeyDown`. Первое событие обрабатывает ввод текста, обновляя состояние компонента через вызов `setFilterText`, а также фильтрует список чатов `chats` по имени контакта, также обновляя компоненту вызовом `setChats`. Второе событие отслеживает нажатие стрелочек и по ним обновляет индекс выбранного с клавиатуры чата (для него будет добавляться подсветка).

Обращать внимание на хук `useCallback` мы не будем, поскольку он связан с оптимизациями обновления компонентов. Говорить о нем будем в других лекциях.

Далее идет вызов хука `useEffect`. Этот хук многофункционален. С помощью него в функциональном компоненте можно вызывать обработчики различных фаз жизненного цикла компоненты. `useEffect` принимает два аргумента: коллбэк и массив зависимостей (об этом тоже будем говорить позднее). Если массив зависимостей пустой, то коллбэк вызовется один раз в фазе монтирования компоненты в виртуальное дерево Virtual DOM. Фаза монтирования обрабатывается один раз (грубо говоря при создании компонента). Внутри нашего колбэка мы пытаемся получить доступные чаты. Здесь мы имитируем обращение к API бекенда через setTimeout, который разрешает наш `Promise` (про Promise так же будем говорить подробнее, но если кратко, то в языке JavaScript на этом типе построено асинхронное взаимодействие между компонентами системы).

Далее идет описание JSX компоненты. Обратите внимание на `input`, на который мы вешаем обработчики событий `onChange` и `onKeyDown`. Первое событие срабатывает при изменении значения в поле ввода. Второе - при нажатии клавиши, когда поле ввода находится в фокусе. Взаимодействие с полем ввода влечет за собой вызов обработчиков. Внутри обработчиков мы вызываем функции обновления состояния нашего компонента. Вызов этих функций влечет за собой перерисовку компонент. Таким образом выстраивается data-flow нашего приложения (однонаправленный поток). Данные спускаются от родительских компонент в дочерние, а дочерние компоненты в свою очередь выбрасывают события, которые мы обрабатываем в наших обработчиках, обновляя состояния. В этом и состоит вся работа с состоянием React-компонент.

#### Работа со сложным состоянием

Помимо простых объектов, состояние может быть представлено некоторым сложным объектом или массивом объектов. Рассмотрим, простую задачу - список TODO. Мы имеем простой массив из объектов, которые хранят описание TODO (какое-то дело) и статус дела в виде флага (выполнено или нет). React устроен таким образом, что чтобы произошло обновления состояния, например, какое-то TODO мы выполнили, то должна поменяться ссылка на объект, который описывает это состояние. То есть в качестве состояния мы имеем массив TODO. JavaScript - объектный язык программирования. При записи объекта в переменную мы фактически сохраняем ссылку на объект в куче. Так вот, с точки зрения React, чтобы обновить состояние (массив TODO), нам необходимо создать новый массив (он будет иметь другую ссылку) и скопировать в него все объекты TODO, кроме измененного. Объект описывающий новую TODO-задачу так же должен быть пересоздан. Поэтому в React очень часто приходится использовать операторы деструктуризации, разбирая объект по свойствам, на основе которых создается новый объект с измененным свойством. Пример:

```jsx
const [todos, setTodos] = useState([]);

const toggleTodo = (todoIndex) => {
    const updatedTodos = todos.slice();
    updatedTodos[todoIndex] = {
        ...updatedTodos[todoIndex],
        done: !updatedTodos[todoIndex].done
    }

    setTodos(updatedTodos);
}
```

В этом примере мы вызываем у массива `todos` метод `slice`, который создает новую ссылку (по факту новый массив) и копирует в него элементы (ссылки на объекты TODO). Далее мы пересоздаем объект по индексу `todoIndex`, заменяя старый объект новым.

Зачем мы это делаем? Дело в том, что библиотека React старается оптимизировать процессы перерисовки интерфейса. И делает он это согласно концепции - все объекты, описывающие состояние являются иммутабельными. Иммутабельный объект - тот, чье состояние не меняется в процессе его жизни. Состояние это совокупность значение его свойств. Если мы меняем какое-то свойство у существующего объекта, то мы мутируем его состояние. Так вот React при работе с состоянием не видит мутаций объектов. Он опирается на обновленные ссылки.

Из-за этого в React порой тяжело работать со сложными формами, состояние которых описывается сложным объектом, поскольку приходится пересоздавать всю структуру родительских объектов вплоть до того, который мы отредактировали. Надо изучить, насколько эффективен сборщик мусора в браузере и как работа со сложным состоянием влияет на performance приложения.

Также React тяжел в плане работы с формами в том плане, что на каждое действие необходимо описать свой обработчик с вызов функции обновления состояния. И порой компонент может разрастись длинным полотном. Однако в какой-то степени это упрощает понимание того, как данные циркулируют по компоненте.

#### Оптимизации отрисовок и Virtual DOM

React старается эффективным образом перерисовывать интерфейс, уменьшая количество манипуляций с реальным DOM-деревом, поскольку эти операции являются тяжеловесными. Чтобы сделать процесс обновления эффективным React использует Virtual DOM. Virtual DOM это дерево компонентов React, которое выстраивается из наших компонент, а точнее из JSX-объектов. При обновлении интерфейса React строит новое Virtual DOM дерево и сравнивает его со старым. Если деревья никак не отличаются, то реальное DOM-дерево обновляться не будет. Иначе в реальный DOM будут внесены изменения в соответствии с различиями в построенных Virtual DOM деревьях, вместо перерисовки всего DOM. Теперь новое Virtual DOM дерево будет сравниваться со следующим деревом после изменения состояния компонент.

Однако React не всегда может эффективно отследить, а были ли реальные изменения в состоянии. Компонента считается обновленной в том случае если изменилась ссылка на какой-то props, например, на метод обработчик события. Даже если реальные данные не изменились, например у поля ввода, при вызове функционального компонента следующая конструкция каждый раз будет создавать новый обработчик с новой ссылкой:

```jsx
const [value, setValue] = useState('');

const handler = () => {
    // do something
}

return <input onChange={handler} value={value} />
```

Функция handler каждый раз будет пересоздаваться. Чтобы этого не происходило, есь специальный хук `useCallback`, который каждый раз будет возвращать одну и ту же ссылку на обработчик:

```jsx
const [value, setValue] = useState('');

const handler = useCallback(() => {
    // do something
}, [])

return <input onChange={handler} value={value} />
```

`useCallback` также принимает два параметры - функцию, и список зависимостей. Зависимости это набор переменных, при изменении которых (изменении ссылки) `handler` будет пересоздан (иногда это так же важно учитывать). При использовании пустого списка зависимостей обработчик будет создан только один раз и пересоздаваться больше не будет.

Другой полезный хук - `useMemo` он позволяет мемоизировать сложные вычисления. Посчитали какой-то сложный объект и на каждый вызов он не будет пересчитываться пока так же не измениться массив параметров.

Есть еще одна полезная функция, которая так же решает проблемы с оптимизацией - `memo` (это не хук `useMemo`, поэтому действует н по-другому). Он так же позволяет оптимизировать процесс обновления Virtual DOM, путем задания пользовательских проверок пропсов. Пользователь может задать логику перерисовки компонента при изменении пропсов.

Так что при работе с React придется много думать об эффективности отрисовки компонента. С одной стороны это хорошо, поскольку опытные разработчик могут управлять процессом. С другой стороны неправильное описание компонент может повлиять на производительность ваших компонент.

#### Некоторые недостатки

1. Необходимость прорабатывать структуру приложения. Наиболее популярная - `fsd` ([Feature Sliced Design](https://feature-sliced.github.io/documentation/ru/docs/get-started/overview)) от компании Яндекс.
2. Чтобы повесить несколько CSS-классов на JSX-элемент, необходимо скачать пакет `clsx`.

#### Когда стоит использовать инструмент?

Одной из главных сложностей работы с React - необходимость проектирования архитектуры. Как уже мы с вами говорили, React представляет собой только слой View. Все остальные слои разработчик выстраивает самостоятельно. Поэтому важно ответственно подойти к проектированию, чтобы не тратить время на рефакторинг из-за того, что вы уперлись в потолок расширяемости.

React хорошо использовать на простых проектах, где необходимо отображать очень много данных, которые могут прилетать из различных источников. Классическая архитектура таких приложений - Flux. О ней мы будем говорить в следующих лекциях. Для более сложных приложений со сложной бизнес-логикой лучше воспользоваться другими инструментами, либо пересмотреть подход к архитектуре. Но на больших проектах может казаться, что React местами многословен по сравнению с другими инструментами.

#### Популярные вспомогательные инструменты

`react-route` и `react-router-dom` - позволяют реализовать маршрутизацию в приложении
`@reduxjs/toolkit` и `mobx` - стейт-менеджеры, позволяющие реализовать работу с глобальными состоянием и управлять обменом данных между компонентами
`clsx` - библиотека для формирования сложны классов компонент.
`@mui/material` - библиотека UI-компонент, которая предоставляет готовый ui-toolkit.

## Обзор возможностей фреймворка Angular

Angular - это полноценный фреймворк, который покрывает все потребности разработчиков, предоставляя им полный набор инструментов, диктует структуру проекта и организован в соответствии с архитектурой Model-View-ViewModel. Это архитектурный паттерн, который разделяет логику приложения на три слоя: модель, представление и представление модели.

### Шаблоны (слой представления)

Слой представления - это описание внешнего вида компонентов с помощью синтаксиса шаблонов. Этот синтаксис представляет собой расширение синтаксиса HTML с помощью встроенных и пользовательских директив. Директивы напоминают собой атрибуты HTML-элементов, который позволяют добавлять обработчики, связывать состояние компонента с элементами UI, например, через элементы пользовательского ввода или просто выводить это состояние как текст в разметке компонента.

## Обзор возможностей прогрессивного фреймворка Vue

## Обзор возможностей фреймворка Aurelia


